<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Housing Inventory Explorer</title>
    <script type="module" src="https://js.arcgis.com/calcite-components/2.1.0/calcite.esm.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/2.1.0/calcite.css"/>
    <!-- Load the Chart.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js"></script>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/dark/main.css" />
    <script src="https://js.arcgis.com/4.28/"></script>
    <script src="js/symbology.js"></script>
    <link rel="stylesheet" href="css/style.css">

    <script>
      // sets the calcite select boxes to a specified value
      function setCalciteSelectValue(selectElement, newValue) {
  
        // Find the option with the specified value
        const optionToSelect = Array.from(selectElement.children)
          .find(option => option.value === newValue);

        if (optionToSelect) {
          // Set the 'selected' attribute on the option
          optionToSelect.setAttribute('selected', '');

          // Dispatch a 'change' event to simulate user interaction
          const changeEvent = new Event('change', { bubbles: true });
          selectElement.dispatchEvent(changeEvent);
        }
      }

      // read in a local json
      function fetchLocalJsonArray(filePath) {
        return fetch(filePath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .catch(error => {
            console.error('Error reading JSON file:', error);
          });
      }

      // populate a select box
      function populateSelectBox(selectName, array) {
        const selectBox = document.getElementById(selectName);

        // Clear existing options
        selectBox.innerHTML = '';

        // Populate with options from the array
        array.forEach(item => {
          const option = document.createElement('calcite-option');
          // option.value = item.value;  // Set the value attribute if needed
          option.setAttribute('value', item)
          option.setAttribute('label', item)
          // option.text = item;    // Set the text content of the option
          selectBox.appendChild(option);
      });
    }
      
      // populate a combobox
      function populateComboBox (comboBoxName, array) {
          const comboBox = document.getElementById(comboBoxName);

          // Populate with options from the array
          array.forEach(item => {
            const comboItem  = document.createElement('calcite-combobox-item');
            // option.value = item.value;  // Set the value attribute if needed
            comboItem.setAttribute('value', item)
            comboItem.setAttribute('text-label', item)
            comboBox.appendChild(comboItem);
        });
      }

      function hideAndResetDefinition(feature){
        feature.definition = null;
        feature.visible = false;
      }


      require(["esri/config",
               "esri/Map", 
               "esri/geometry/Point",
               "esri/layers/FeatureLayer", 
               "esri/views/MapView", 
               "esri/widgets/Legend",
               "esri/widgets/TimeSlider",
               "esri/widgets/Expand",
               "esri/widgets/BasemapGallery",
               "esri/core/reactiveUtils",
               "esri/core/promiseUtils",
               "esri/rest/support/Query"], (
        esriConfig,
        Map,
        Point,
        FeatureLayer,
        MapView,
        Legend,
        TimeSlider,
        Expand,
        BasemapGallery,
        reactiveUtils,
        promiseUtils,
        Query
      ) => {

        esriConfig.apiKey = "AAPK5915b242a27845f389e0a11a17dc46b46gXNFj09FJVdb711lVLGhgoVFJBqdW6ow3bl71N1hx2llpMyogGBeF8kgvrKm3cY";

        // store the base url
        const providedURL =  window.location;
        let newURL = new URL(providedURL)
        const urlParamsToggle = true;

        // store paths to jsons
        const jsonBase = 'json/BASE.json';
        const jsonCounty = 'json/COUNTY.json';
        const jsonCity = 'json/CITY.json';
        const jsonCenter = 'json/CENTER.json';
        const jsonType = 'json/TYPE.json';
        const jsonCenterType = 'json/CENTER_TYPE.json';
        
        let activeLayer;

        // initialize geographic filter options
        fetchLocalJsonArray(jsonBase)
        .then(data => {
          const countyArray = data[0].COUNTY;
          const cityArray = data[0].CITY;
          const centerArray = data[0].CENTER;
          populateSelectBox('countySelect', countyArray);
          populateSelectBox('citySelect', cityArray);
          populateSelectBox('centerSelect', centerArray);
        });

        // initialize housing type options
        fetchLocalJsonArray(jsonType)
        .then(data => {
          const subtypeArray = data[0].SUBTYPE;
          populateComboBox('subtypeSelect', subtypeArray);
        });

        // initialize housing type options
        fetchLocalJsonArray(jsonCenterType)
        .then(data => {
          const centerTypeArray = data[0].CENTERTYPE;
          populateComboBox('centerTypeSelect', centerTypeArray);
        });

        const countiesLayer = new FeatureLayer({
                outFields: ["CO_NAME"],
                url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/Boundaries_gdb/FeatureServer/1",
                renderer:countyRenderer,
                maxScale: 0,
                visible: false
              });
              
        const citiesLayer = new FeatureLayer({
                outFields: ["NAME"],
                url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/Boundaries_gdb/FeatureServer/0",
                renderer:cityRenderer,
                maxScale: 0,
                // minScale: 100000,
                visible: false
        
              });

        const centersLayer = new FeatureLayer({
                outFields: ["AreaName"],
                url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/Boundaries_gdb/FeatureServer/2",
                renderer:centerRenderer,
                maxScale: 0,
                // minScale: 50000,
                visible: false
              });

        const ParcelsLayer = new FeatureLayer({
            outFields: ["*"],
            url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/hui_for_web_gdb/FeatureServer/0",
            renderer:parcelRenderer,
            maxScale: 0,
            visible: false,
            popupTemplate:parcelPopupTemplate
          });
        
        const PointsLayer = new FeatureLayer({
            url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/hui_for_web_gdb/FeatureServer/1",
            renderer:pointRenderer,
            outFields: ["*"],
            visible: true,
          });


        // Create the Map and View objects
        const defaultZoom = 14
        const map = new Map({
          basemap: "satellite",
          layers: [PointsLayer, ParcelsLayer, centersLayer, citiesLayer, countiesLayer],
        });

        const view = new MapView({
          container: "viewDiv",
          map: map,
          zoom: defaultZoom,
          center: [-111.90, 40.76]
        });

        // // move the zoom icon
        // view.ui.move("zoom", "bottom-left");

        if (newURL.searchParams.toString() === '') {
          activeLayer = PointsLayer;
          console.log('no url params')
        }else{
          // var newURL = new URL(providedURL)
          console.log('has url params')
              var searchParams = newURL.searchParams;
              var geomParam = searchParams.get("geom");

              var countyParam = searchParams.get("cny");
              var cityParam = searchParams.get("cty");
              var centerParam = searchParams.get("ctr");
              var subtypeParam = searchParams.get("type");
              var centerTypeParam = searchParams.get("cen");
              

              var lrParam = searchParams.get("lr");
              var frParam = searchParams.get("fr");
              var brtParam = searchParams.get("brt");
              var fwyeParam = searchParams.get("fwye");
              var pkParam = searchParams.get("pk");
              var trlParam = searchParams.get("trl");
              var logOpParam = searchParams.get("op");
              var yrbParam = searchParams.get("yrb");
              var yreParam = searchParams.get("yre");

              var xParam = parseInt(searchParams.get("x"));
              var yParam = parseInt(searchParams.get("y"));
              var zoomParam = parseInt(searchParams.get("zoom"));

              if (geomParam === 'pcl'){
                activeLayer = ParcelsLayer;
              } if (geomParam === 'pt'){
                activeLayer = PointsLayer;
              }
        }

        // view.ui.move("zoom", "top-right");


        // create the base map gallery expand object
        const basemapGallery = new BasemapGallery({
                view: view,
                container: document.createElement("div")
              });

        // Create an Expand instance and set the content
        // property to the DOM node of the basemap gallery widget
        // Use an Esri icon font to represent the content inside
        // of the Expand widget
        const bgExpand = new Expand({
          expandTooltip: "Basemap",
          view: view,
          content: basemapGallery,
          group: "top-right"
        });

        // add the App Info chart div
        const infoDiv = document.getElementById("infoDiv");
        const infoDivExpand = new Expand({
          expandIcon: "information",
          expandTooltip: "Info",
          view,
          content: infoDiv,
          expanded: false,
          group: "top-right"
        });
        
      

        // close the expand whenever a basemap is selected
        // on mobile devices
        reactiveUtils.watch(
          () => basemapGallery.activeBasemap,
          () => {
            const mobileSize = view.heightBreakpoint === "xsmall" || view.widthBreakpoint === "xsmall";

            if (mobileSize) {
              bgExpand.collapse();
            }
          }
        );

  
        // when the view object is created, create a time slider
        view.when(() => {
                    timeSlider = new TimeSlider({
                      container: "timeSlider",
                      view: view,
                      // full min max of time slider
                      fullTimeExtent: { 
                        start: new Date(1850, 0, 1),
                        end: new Date(2022, 0, 1)
                      },
                      // starting min max of time slider
                      timeExtent:{ 
                        start: new Date(1850, 0, 1),
                        end: new Date(2022, 0, 1)
                      },
                      // play speed, not needed?
                      playRate: 2000, 
                      stops: {
                        interval: {
                          value: 1,
                          unit: "years"
                        }
                      },
                      
                      // set custom labels for the timeslider's min, max, and extent dates
                      labelFormatFunction: (value, type, element, layout) => {
                        const options = {year: 'numeric'}
                        const normal = new Intl.DateTimeFormat("en-us", options);
                        switch (type) {
                          case "min":
                            element.setAttribute("style", "color: #00619B;font-size: 14px;");
                            element.innerText = normal.format(value);
                            break;
                          case "max":
                            element.setAttribute("style", "color: #00619B;font-size: 14px;");
                            element.innerText = normal.format(value);
                            break;
                          case "extent":
                            const year0 = value[0].getFullYear();
                            const year1 = value[1].getFullYear()
                            element.innerText = `Year Built:
                            ${year0} - ${year1}`;
                            break;
                        }
                      }
                    });
                  

                  // Option 1: time slider expand
                  const timeSliderExpand = new Expand({
                      expandIcon: "calendar",
                      expandTooltip: "TimeSlider",
                      view,
                      content: timeSlider.container,
                      expanded: false
                    });
                  
                  view.ui.add(timeSliderExpand, "bottom-left");
           
                  // watch the time slider for changes
                  reactiveUtils.watch(
                    () => timeSlider.timeExtent,
                    (timeExtent) => {
                      yStart = timeExtent.start.getFullYear();
                      yEnd = timeExtent.end.getFullYear();
                      view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
                      // yearQuery = `APX_BLT_YR >= '${yStart}' AND APX_BLT_YR <= '${yEnd}'`
                      // generateFullQuery()
                      // console.log(fullQuery)
                      // activeLayer.definitionExpression = fullQuery;
                    }
                  );

                  // Option 2: add the time slider (non-expandable) to the view, manual allows for div placement
                  // view.ui.add(timeSlider, "manual");
        });

        
        
        // store ui objects as variables
        const countySelect = document.getElementById("countySelect");
        const citySelect = document.getElementById("citySelect");
        const centerSelect = document.getElementById("centerSelect");
        const subtypeSelect = document.getElementById("subtypeSelect");
        const centerTypeSelect = document.getElementById("centerTypeSelect");
        const resetButton = document.getElementById("resetButton");
        
        // define default queries
        const defaultCountyQuery = "(COUNTY IS NULL OR COUNTY IS NOT NULL)";
        const defaultCityQuery = "(CITY IS NULL OR CITY IS NOT NULL)";
        const defaultCenterQuery = "(CENTER IS NULL OR CENTER IS NOT NULL)";
        const defaultSubtypeQuery = "(SUBTYPE IS NULL OR SUBTYPE IS NOT NULL)";
        const defaultCenterTypeQuery = "(CENTERTYPE IS NULL OR CENTERTYPE IS NOT NULL)";

        const defaultLRquery = null;
        const defaultFRquery = null;
        const defaultBRTquery = null;
        const defaultFWYEquery = null;
        const defaultPARKquery = null;
        const defaultTRAILquery = null;
        const defaultLogicOperator =  "AND";

        const defaultYearQuery = "(APX_BLT_YR IS NULL OR APX_BLT_YR IS NOT NULL)"

        // set initial selection for geography filters - could switch to a placeholder?
        let countySelectionCurrent = "-No Selection-";
        let citySelectionCurrent = "-No Selection-";
        let centerSelectionCurrent = "-No Selection-";

        let countyQuery = defaultCountyQuery;
        let cityQuery = defaultCityQuery;
        let centerQuery = defaultCenterQuery;
        let subtypeQuery = defaultSubtypeQuery;
        let centerTypeQuery = defaultCenterTypeQuery;

        let LRquery = null;
        let FRquery = null;
        let BRTquery = null;
        let FWYEquery = null;
        let PARKquery = null;
        let TRAILquery = null;
        let logicOperator =  defaultLogicOperator;
        let yearQuery = defaultYearQuery;

        let fullQuery = null;

        let countyActive = false;
        let cityActive = false;
        let centerActive = false;

        function generateFullQuery() {
       
          const queryComponents = [countyQuery, cityQuery, centerQuery, subtypeQuery, centerTypeQuery];
          const distArray = [LRquery, FRquery, BRTquery, FWYEquery, PARKquery, TRAILquery].filter(item => item !== null);

          const hasDistValues = distArray.length > 0;

          const distQuery = hasDistValues
              ? ` AND (${distArray.join(` ${logicOperator} `)})`
              : '';

          fullQuery = queryComponents.join(' AND ') + distQuery;
          // console.log(fullQuery);
        };

         // define initial definition expression
        const initialDefinitionExpression = generateFullQuery()

        // setup actions for the reset button
        resetButton.addEventListener("click", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => {
          
            // clear the definition expression
            // layer.definitionExpression = null;
            view.whenLayerView(layer).then((layerView) => {
                layerView.filter = null;
              });
          });

          hideAndResetDefinition(countiesLayer)
          hideAndResetDefinition(citiesLayer)
          hideAndResetDefinition(centersLayer)

          countyActive = false
          cityActive = false
          centerActive = false

          countySelectionCurrent = "None";
          citySelectionCurrent = "None";
          centerSelectionCurrent = "None";

          fetchLocalJsonArray(jsonBase)
            .then(data => {
              
              const countyArray = data[0].COUNTY;
              const cityArray = data[0].CITY;
              const centerArray = data[0].CENTER;
              populateSelectBox('countySelect', countyArray);
              populateSelectBox('citySelect', cityArray);
              populateSelectBox('centerSelect', centerArray);

            });

            countyQuery = defaultCountyQuery;
            cityQuery = defaultCityQuery;
            centerQuery = defaultCenterQuery;
            subtypeQuery = defaultSubtypeQuery;
            centerTypeQuery = defaultCenterTypeQuery;
            LRquery = null;
            FRquery = null;
            BRTquery = null;
            FWYEquery = null;
            PARKquery = null;
            TRAILquery = null;
            logicOperator =  defaultLogicOperator;
            yearQuery = defaultYearQuery;
            
            subtypeSelect.value = null;
            centerTypeSelect.value = null;
            inputLR.value = null;
            inputFR.value = null;
            inputBRT.value = null;
            inputFWYE.value = null;
            inputPARK.value = null;
            inputTRAIL.value = null;
            logicOperator = "And"; 
            generateFullQuery()
            andButton.style.backgroundColor = "#00619B";
            orButton.style.backgroundColor = "#797979";
            
            // reset time slider
            timeSlider.timeExtent.start = new Date(1850, 0, 1);
            timeSlider.timeExtent.end = new Date(2022, 0, 1);
        

          newURL.searchParams.delete('cny');
          newURL.searchParams.delete('cty');
          newURL.searchParams.delete('ctr');
          newURL.searchParams.delete('type');
          newURL.searchParams.delete('lr');
          newURL.searchParams.delete('fr');
          newURL.searchParams.delete('brt');
          newURL.searchParams.delete('fwye');
          newURL.searchParams.delete('pk');
          newURL.searchParams.delete('trl');
          andButton.click()
          window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

          view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
        });

        // setup actions for the AND button
        andButton.addEventListener("click", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => {  
            logicOperator = "And"; 
            generateFullQuery()
            newURL.searchParams.set("op", logicOperator)
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
            // layer.definitionExpression = fullQuery;
            view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            
            andButton.style.backgroundColor = "#00619B";
            orButton.style.backgroundColor = "#797979";
          });
        });

        // setup actions for the OR button
        orButton.addEventListener("click", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => {  
            logicOperator = "Or";
            newURL.searchParams.set("op", logicOperator)
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
            generateFullQuery()
            // layer.definitionExpression = fullQuery;
            view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            orButton.style.backgroundColor = "#00619B";
            andButton.style.backgroundColor = "#797979";
          });
        });

        // COUNTY - filter and zoom features, update select options
        countySelect.addEventListener("calciteSelectChange", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app


            selectionText = event.target.value;

            countySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              newURL.searchParams.delete('cny');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              countyQuery = defaultCountyQuery
              countyActive = false
            }else{
              // update URL params
              newURL.searchParams.set("cny", selectionText)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              countyQuery = `COUNTY = '${selectionText}'`
              countyActive = true
            };

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            // layer.definitionExpression = fullQuery;
            view.whenLayerView(layer).then((layerView) => {
              layerView.filter = {where: fullQuery};
            });

            // update the select options
            fetchLocalJsonArray(jsonCounty)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;
              
              if ((cityActive !== true) && (centerActive !== true)){
                populateSelectBox('citySelect', cityArray);
                populateSelectBox('centerSelect', centerArray);   
              }           
              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)

            });
          });
          // housingLayer.queryExtent().then((results) => {
          //   view.goTo(results.extent);
          // });
          
          // show county outline
          hideAndResetDefinition(citiesLayer)
          hideAndResetDefinition(centersLayer)
          countiesLayer.definitionExpression = `CO_NAME = '${selectionText}'`;
          countiesLayer.visible = true;

          // zoom to the boundary layer (faster but zooms farther out)
          const query = new Query();
          query.where = `CO_NAME = '${selectionText}'`;
          countiesLayer.queryExtent(query).then(function(results){
            view.goTo(results.extent);
          });
        });

        // CITY - filter and zoom features, update select options
        citySelect.addEventListener("calciteSelectChange", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            // selectionText = citySelect.options[citySelect.selectedIndex].text;
            selectionText = event.target.value;
            citySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              newURL.searchParams.delete('cty');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              cityQuery = defaultCityQuery;
              cityActive = false;
            }else{
              newURL.searchParams.set("cty", selectionText)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              cityQuery = `CITY = '${selectionText}'`;
              cityActive = true;
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            // layer.definitionExpression = fullQuery;

            view.whenLayerView(layer).then((layerView) => {
              layerView.filter = {where: fullQuery};
            });
            
            // update the select options
            fetchLocalJsonArray(jsonCity)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

             
              if ((countyActive !== true) && (centerActive !== true)){
                populateSelectBox('countySelect', countyArray);
                populateSelectBox('centerSelect', centerArray);              
              } if ((countyActive === true)){
                  populateSelectBox('countySelect', countyArray);
                  populateSelectBox('centerSelect', centerArray);
              } if ((centerActive === true)){
                  populateSelectBox('centerSelect', centerArray);
              }

              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)
            });
          });

            // show city outline
            hideAndResetDefinition(countiesLayer)
            hideAndResetDefinition(centersLayer)            
            citiesLayer.definitionExpression = `NAME = '${selectionText}'`;
            citiesLayer.visible = true;

            // zoom to the boundary layer instead
            const query = new Query();
            query.where = `NAME = '${selectionText}'`;
            citiesLayer.queryExtent(query).then(function(results){
              view.goTo(results.extent);
            });

        });

        // CENTER - filter and zoom features, update select options
        centerSelect.addEventListener("calciteSelectChange", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selectionText = event.target.value;
            centerSelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              newURL.searchParams.delete('ctr');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              centerQuery = defaultCenterQuery;
              centerActive = false;
            }else{
              // update URL params
              newURL.searchParams.set("ctr", selectionText)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              centerQuery = `CENTER = '${selectionText}'`
              centerActive = true;
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            // layer.definitionExpression = fullQuery;

            view.whenLayerView(layer).then((layerView) => {
              layerView.filter = {where: fullQuery};
            });
            
            // update the select options
            fetchLocalJsonArray(jsonCenter)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

            
              if ((countyActive !== true) && (cityActive !== true)){
                populateSelectBox('countySelect', countyArray);
                populateSelectBox('citySelect', cityArray);          
              } if ((countyActive === true)){
                  populateSelectBox('countySelect', countyArray);
                  populateSelectBox('citySelect', cityArray);
              } if ((cityActive === true)){
                  populateSelectBox('citySelect', cityArray);
              }

              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)

            });
          });
          
          // show center outline
          hideAndResetDefinition(countiesLayer)
          hideAndResetDefinition(citiesLayer)
          centersLayer.definitionExpression = `AreaName = '${selectionText}'`;
          centersLayer.visible = true;

          // zoom to the boundary layer instead
          const query = new Query();
          query.where = `AreaName = '${selectionText}'`;
          centersLayer.queryExtent(query).then(function(results){
            view.goTo(results.extent);
          });

        });

        // SUBTYPE Select
        subtypeSelect.addEventListener("calciteComboboxChange", (event) => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selection = event.target.value;
            console.log(selection);

            if (Array.isArray(selection) == false){
              if(selection === null | selection === " " | selection === ""){

                newURL.searchParams.delete('type');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
                subtypeQuery = defaultSubtypeQuery
              }else{
                // update URL params
                
                newURL.searchParams.set("type", selection)
                window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

                subtypeQuery = `SUBTYPE IN ('${selection}')`
              }
            }else{
              // const joinedString = selection.join('-');
              newURL.searchParams.set("type", selection)
                window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              selection = selection.map(value => `'${value}'`);
              subtypeQuery = `SUBTYPE IN (${selection})`
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            // layer.definitionExpression = fullQuery;
            view.whenLayerView(layer).then((layerView) => {
              layerView.filter = {where: fullQuery};
            });

          });
          view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
        });

        // CENTERTYPE Select
        centerTypeSelect.addEventListener("calciteComboboxChange", (event) => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selection = event.target.value;
            console.log(selection);

            if (Array.isArray(selection) == false){
              if(selection === null | selection === " " | selection === ""){

                newURL.searchParams.delete('cen');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
                centerTypeQuery = defaultCenterTypeQuery
              }else{
                // update URL params
                
                newURL.searchParams.set("cen", selection)
                window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

                centerTypeQuery = `CENTERTYPE IN ('${selection}')`
              }
            }else{
              // const joinedString = selection.join('-');
              newURL.searchParams.set("cen", selection)
                window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              selection = selection.map(value => `'${value}'`);
              centerTypeQuery = `CENTERTYPE IN (${selection})`
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            // layer.definitionExpression = fullQuery;
            view.whenLayerView(layer).then((layerView) => {
              layerView.filter = {where: fullQuery};
            });

          });
          view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
        });

        //initialize light rail dist filter
        const inputLR  = document.getElementById("inputLR");
        inputLR.value = null;
        inputLR.addEventListener("calciteInputChange", function(){

            userInput = inputLR.value;
            console.log(typeof(userInput))

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('lr');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              LRquery = defaultLRquery;
              
            }  else {
              // update URL params
              newURL.searchParams.set("lr", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              LRquery = `DIST_LR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              // layer.definitionExpression = fullQuery;
              view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            });
            view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
          });


        //initialize frontrunner dist filter
        const inputFR  = document.getElementById("inputFR");
        inputFR.value = null;
        inputFR.addEventListener("calciteInputChange", function(){

            userInput = inputFR.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              
              newURL.searchParams.delete('fr');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              FRquery = defaultFRquery;
            }  else {
              // update URL params
              newURL.searchParams.set("fr", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              FRquery = `DIST_FR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              // layer.definitionExpression = fullQuery;
              view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            });
            view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
          });

        //initialize BRT dist filter
        const inputBRT  = document.getElementById("inputBRT");
        inputBRT.value = null;
        inputBRT.addEventListener("calciteInputChange", function(){

            userInput = inputBRT.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('brt');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              BRTquery = defaultBRTquery;
            }  else {
              // update URL params
              newURL.searchParams.set("brt", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              BRTquery = `DIST_BRT <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              // layer.definitionExpression = fullQuery;
              view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            });
            view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
          });

        //initialize FWYE dist filter
        const inputFWYE  = document.getElementById("inputFWYE");
        inputFWYE.value = null;
        inputFWYE.addEventListener("calciteInputChange", function(){

            userInput = inputFWYE.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('fwye');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              FWYEquery = defaultFWYEquery;
            } else {
              // update URL params
              newURL.searchParams.set("fwye", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);

              FWYEquery = `DIST_FWYE <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              // layer.definitionExpression = fullQuery;
              view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            });
            view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
          });

        //initialize PARK dist filter
        const inputPARK  = document.getElementById("inputPARK");
        inputPARK.value = null;
        inputPARK.addEventListener("calciteInputChange", function(){

            userInput = inputPARK.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('pk');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              PARKquery = defaultPARKquery;
            } else {
              // update URL params
              newURL.searchParams.set("pk", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              PARKquery = `DIST_PARK <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              // layer.definitionExpression = fullQuery;
              view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            });
            view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
          });

        //initialize PARK dist filter
        const inputTRAIL  = document.getElementById("inputTRAIL");
        inputTRAIL.value = null;
        inputTRAIL.addEventListener("calciteInputChange", function(){

            userInput = inputTRAIL.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              newURL.searchParams.delete('trl');
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              
              TRAILquery = defaultTRAILquery;
            } else {
              // update URL params
              newURL.searchParams.set("trl", userInput)
              window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
              TRAILquery = `DIST_TRAIL <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              // layer.definitionExpression = fullQuery;
              view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            });
            
            view.whenLayerView(activeLayer).then((layerView) => {
              queryStatisticsForTypeChart(layerView);
              queryStatisticsForYearChart(layerView);
            });
            
          });

        //==============================================
        // on zoom, change unit of representaion
        //==============================================

        view.watch("zoom", function (newZoom) {
          console.log("Zoom level changed to: ", newZoom);

          if (newZoom >= 15){ 
            view.whenLayerView(ParcelsLayer).then((layerView) => {
            reactiveUtils.whenOnce(() => !layerView.updating).then(() => {
              ParcelsLayer.visible = true;
              PointsLayer.visible = false;
            });
          });
          }
          else if (newZoom < 15 && newZoom > 5){ 
            ParcelsLayer.visible = false;
            PointsLayer.visible = true;
            activeLayer = PointsLayer;
          }
        });


        const sidebarDiv = document.getElementById("sidebarDiv");
        const sidebarExpand = new Expand({
          expandIcon: "sliders-horizontal",
          expandTooltip: "Filters",
          view: view,
          content: sidebarDiv,
          expanded: true,
          // group: "top-left"
        });
        view.ui.add(sidebarExpand, { position: "top-left"});

      //=========================
      // chart stuff
      //=========================

      let yearChart = null;
      let typeChart = null;

      const yearCanvas = document.getElementById("year-chart");
      const typeCanvas = document.getElementById("type-chart");

      const queryStatisticsForYearChart = promiseUtils.debounce( async function (layerview) {

          yearChart.options.title.text = "Built Decade (Loading...)"
          yearChart.update();
    
          // create query definitions for stacked bar chart data
          const decades = ["1840", "1850", "1860", "1870", "1880", "1890", "1900", "1910", "1920", "1930", "1940", "1950", "1960", "1970", "1980", "1990", "2000", "2010", "2020"];
          const subtypes = ["single_family", "duplex", "single_family_adu", "condo", "townhome", "mobile_home_park", "mixed_th/single_family", "apartment"];
          const yearChartDefinitions = [];
          for (const decade of decades) {
            for (const subtype of subtypes) {
              const definition = {
                onStatisticField: `CASE WHEN (BLT_DECADE = '${decade}' AND SUBTYPE = '${subtype}') THEN UNIT_COUNT ELSE 0 END`,
                outStatisticFieldName: `year_${decade}_${subtype}`,
                statisticType: "sum"
              };

              yearChartDefinitions.push(definition);
            }
          }
          // console.log(yearChartDefinitions)
          // query for stacked bar chart data
          const yearChartQuery = layerview.createQuery();
          yearChartQuery.where = fullQuery
          yearChartQuery.geometry = view.extent;
          yearChartQuery.outStatistics = yearChartDefinitions;

          

          return layerview.queryFeatures(yearChartQuery).then((result) => {
            const yearChartQueryResult = result.features[0].attributes;
            // console.log(yearChartQueryResult)

            
            const decadeTypeCountArray = [];
            for (const property in yearChartQueryResult) {
              if (yearChartQueryResult.hasOwnProperty(property)) {
                const [year, ...typeParts] = property.split('_').slice(1);

                decadeTypeCountArray.push({
                  decade: +year,
                  type: typeParts.join('_'),
                  count: yearChartQueryResult[property]
                });
              }
            }
            // console.log(decadeTypeCountArray);


              // Calculate the sum of counts for each decade
              const decadeSums = decadeTypeCountArray.reduce((acc, entry) => {
                acc[entry.decade] = (acc[entry.decade] || 0) + entry.count;
                return acc;
              }, {});

              // Filter out objects with a sum of 0 and get an array of unique decades
              const filteredArray = decadeTypeCountArray.filter(entry => decadeSums[entry.decade] !== 0);
              const uniqueDecades = [...new Set(filteredArray.map(entry => entry.decade))];
              // console.log(uniqueDecades);
              
              // create data objects for each housing type
              const stackedChartDataObjects = [];
              const typeData = {};
              for (const entry of filteredArray) {
                const { type, count, decade } = entry;

                if (!typeData[type]) {
                  typeData[type] = {
                    label: type,
                    data: [],
                    backgroundColor:null
                  };
                }
                typeData[type].data.push(count);

                // If the decade is not already added to the data object, add it
                if (typeData[type].data.length === 1) {
                  typeData[type].decade = decade;
                }
              }
              // Convert the object values to an array
              for (const type in typeData) {
                if (typeData.hasOwnProperty(type)) {
                  stackedChartDataObjects.push(typeData[type]);
                }
              }
              // console.log(stackedChartDataObjects);

              // Update the backgroundColor attribute using the typeColorMap
              const typeColorMap = {
                "single_family": '#FAECA7',
                "duplex": '#FC921F',
                "single_family_adu": '#E60049',
                "condo": '#BD7EBE',
                "townhome": '#28C830',
                "mobile_home_park": '#9E559C',
                "mixed_th/single_family": '#1E8553',
                "apartment": '#149ECE'
              };
              
              const updatedDataArray = stackedChartDataObjects.map(item => ({
                ...item,
                backgroundColor: typeColorMap[item.label]
              }));

              // console.log(updatedDataArray);
              
              // yearChart.update();

              updateStackedChart(yearChart, uniqueDecades,updatedDataArray)
          
          }, console.error);

        });

        queryStatisticsForTypeChart = promiseUtils.debounce(function (layerView) {
          
          typeChart.options.title.text = "Housing Type (Loading...)"
          typeChart.update();

          const statDefinitions = [
            {
              onStatisticField: "CASE WHEN SUBTYPE IS NOT NULL THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "total",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'single_family' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "single_family",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'duplex' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "duplex",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'single_family_adu' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "single_family_adu",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'townhome' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "townhome",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'condo' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "condo",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'mobile_home_park' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "mobile_home_park",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'mixed th/single_family' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "mixed_th_single_family",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'apartment' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "apartment",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1840') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1840",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1850') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1850",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1860') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1860",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1870') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1870",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1880') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1880",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1890') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1890",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1900') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1900",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1910') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1910",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1920') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1920",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1930') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1930",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1940') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1940",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1950') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1950",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1960') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1960",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1970') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1970",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1980') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1980",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1990') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1990",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2000') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2000",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2010') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2010",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2020') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2020",
              statisticType: "sum"
            } 
          ];
           
          // query data for the pie chart
          const query = layerView.createQuery();
          query.where = fullQuery
          query.geometry = view.extent;
          query.outStatistics = statDefinitions;
          return layerView.queryFeatures(query).then((result) => {
            const allStats = result.features[0].attributes;
            document.getElementById("countDiv").innerHTML = allStats.total;
          
            

            updateChart(typeChart, [
              allStats.single_family,
              allStats.duplex,
              allStats.single_family_adu,
              allStats.condo,
              allStats.townhome,
              allStats.mobile_home_park,
              allStats.mixed_th_single_family,
              allStats.apartment
            ]);

          }, console.error);
        });

        // Updates the given chart with new data
        function updateChart(chart, dataValues) {
          chart.data.datasets[0].data = dataValues;
          typeChart.options.title.text = "Housing Type"
          chart.update();
        }

        // Updates the given chart with new data
        function updateStackedChart(chart, labels, dataValues) {
          chart.data.labels = labels;
          chart.data.datasets = dataValues;
          chart.options.title.text = "Built Decade"
          chart.update();
        }

        // instantiate the year stacked chart
        function createYearChart() {
          // const yearCanvas = document.getElementById("year-chart");
          yearChart = new Chart(yearCanvas.getContext("2d"), {
            type: "bar",
            data: {
              labels: [],
              datasets: [
                {
                  label: null,
                  backgroundColor: "#149dcf",
                  data: []
                }
              ]
            },
            options: {
              // responsive: false,
              legend: {
                display: false
              },
              title: {
                display: true,
                text: "Built Decade",
                fontColor:"#FFFFFF",
                fontSize:13
              },
              scales: {
                xAxes: [
                  {
                    stacked: true,
                    ticks: {
                      beginAtZero: true,
                      precision: 0,
                      fontColor: '#FFFFFF'
                    },
                    gridLines:{color: '#ccc'}
                  }
                ],
                yAxes: [
                  {
                    stacked: true,
                    ticks:{
                      fontColor: '#FFFFFF'
                    },
                    gridLines:{color: '#ccc'}
                  }
                ]
              }
            }
          });
          yearCanvas.style.backgroundColor = 'rgba(75,75,75,1)';
          yearCanvas.style.border = '1px solid #ccc';
        }

        // instantiate the type pie chart
        function createTypeChart() {
          // const typeCanvas = document.getElementById("type-chart");
          typeChart = new Chart(typeCanvas.getContext("2d"), {
            type: "doughnut",
            data: {
              labels: ["single_family", "duplex", "single_family_adu", "condo", 
                       "townhome", "mobile_home_park", "mixed th/single_family", "apartment"],
              datasets: [
                {
                  backgroundColor: ["#FAECA7", "#FC921F", "#E60049", "#BD7EBE", 
                                    "#28C830", "#9E559C", '#1E8553', '#149ECE'],
                  borderWidth: 0,
                  data: [0, 0, 0, 0, 0, 0, 0, 0]
                }
              ]
            },
            options: {
              responsive: true,
              cutoutPercentage: 25,
              legend: {
                display:false,
                position: "top",
              },
              layout: {
                padding:{bottom: 15}
               },
              title: {
                display: true,
                text: "Housing Type",
                fontColor:"#FFFFFF",
                fontSize:13
              }
            }
          });
          typeCanvas.style.backgroundColor = 'rgba(75,75,75,1)';
          typeCanvas.style.border = '1px solid #ccc';
        }

        // create the charts
        createYearChart();
        createTypeChart();

        // when the extent is changed update the charts
        reactiveUtils.when(() => view.stationary === true, () => {
          
          view.whenLayerView(activeLayer).then((layerView) => {
            reactiveUtils
              .whenOnce(() => !layerView.updating)
              .then(() => {
                // Query layer view statistics as the user clicks
                // or drags the pointer across the view.
                queryStatisticsForTypeChart(layerView)
		            queryStatisticsForYearChart(layerView)
                ;
              });
          });

          
        });

        // // Another method of updating the charts, when data is done updating
        // view.whenLayerView(activeLayer).then((layerView) => {
        //     reactiveUtils.when(() => !layerView.dataUpdating, () => {
        //       queryStatisticsForYearChart();
        //       queryStatisticsForTypeChart();

        //     });
        //   });

        // create an expand object for the charts
        const resultDiv = document.getElementById("resultDiv");
        const chartExpand = new Expand({
          expandIcon: "graph-bar-side-by-side",
          expandTooltip: "Statistics",
          view: view,
          content: resultDiv,
          expanded: true,
          group: "top-right"
        });

        view.when(() => {
                // get the first layer in the collection of operational layers in the WebMap
                // when the resources in the MapView have loaded.
                const legend = new Legend({
                  view: view,
                  layerInfos: [
                    {
                      layer: PointsLayer,
                      title: ""
                    },
                    {
                      layer: ParcelsLayer,
                      title: ""
                    }
                  ]
                });

                const legendExpand = new Expand({
                expandIcon: "legend",
                expandTooltip: "Legend",
                view: view,
                content: legend,
                group: "top-right"
                });

                // Add widget to the bottom right corner of the view
                view.ui.add(legendExpand, "top-right");
              });
        
        view.ui.add(infoDivExpand, "top-right");
        view.ui.add(chartExpand, { position: "top-right"});
        view.ui.add(bgExpand, "top-right");


        //===============================
        // urlParams Functionality
        //===============================
        view.when(() => {
          // if provide URL has searchParams update the map
          if (urlParamsToggle === true){
            if (newURL.searchParams.toString() !== '') {
              // var newURL = new URL(providedURL)
              // var searchParams = newURL.searchParams;
              // var geomParam = searchParams.get("geom");

              // var countyParam = searchParams.get("cny");
              // var cityParam = searchParams.get("cty");
              // var centerParam = searchParams.get("ctr");
              // var subtypeParam = searchParams.get("type");

              // var lrParam = searchParams.get("lr");
              // var frParam = searchParams.get("fr");
              // var brtParam = searchParams.get("brt");
              // var fwyeParam = searchParams.get("fwye");
              // var logOpParam = searchParams.get("op");

              // var xParam = parseInt(searchParams.get("x"));
              // var yParam = parseInt(searchParams.get("y"));
              // var zoomParam = parseInt(searchParams.get("zoom"));
   
              if ((countyParam != 'None') && countyParam){
                countySelect.value = countyParam;
                countyQuery = `COUNTY = '${countyParam}'`
                // console.log(countyParam);
              };

              if ((cityParam != 'None') && cityParam){
                citySelect.value = cityParam;
                cityQuery = `CITY = '${cityParam}'`
              };

              // center url params
              if ((centerParam != 'None') && centerParam){
                centerSelect.value = centerParam;
                centerQuery = `CENTER = '${centerParam}'`
              };
              
              // subtype url params
              if ((subtypeParam != 'None') && subtypeParam){
                if (subtypeParam.includes(',')) {
                  subtypeParam = subtypeParam.split(',');
                  subtypeSelect.value = subtypeParam;
                subtypeQuery = `SUBTYPE IN (${subtypeParam})`
                } else{
                  subtypeSelect.value = subtypeParam;
                  subtypeQuery = `SUBTYPE IN ('${subtypeParam}')`
                }
              };

              // centertype url params
              if ((centerTypeParam != 'None') && centerTypeParam){
                if (centerTypeParam.includes(',')) {
                  centerTypeParam = centerTypeParam.split(',');
                  centerTypeSelect.value = centerTypeParam;
                  centerTypeQuery = `CENTERTYPE IN (${centerTypeParam})`
                } else{
                  centerTypeSelect.value = centerTypeParam;
                  centerTypeQuery = `CENTERTYPE IN ('${centerTypeParam}')`
                }
              };

              // light rail url params
              if ((lrParam != 'None') && lrParam){
                inputLR.value = lrParam;
                LRquery = `DIST_LR <= '${lrParam}'`
              };

              if ((frParam != 'None') && frParam){
                inputFR.value = frParam;
                FRquery = `DIST_FR <= '${frParam}'`
              };

              if ((brtParam != 'None') && brtParam){
                inputBRT.value = brtParam;
                BRTquery = `DIST_BRT <= '${brtParam}'`
              };

              if ((fwyeParam != 'None') && fwyeParam){
                inputFWYE.value = fwyeParam;
                FWYEquery = `DIST_FWYE <= '${fwyeParam}'`
              };

              if ((pkParam != 'None') && pkParam){
                inputPARK.value = pkParam;
                PARKquery = `DIST_PARK <= '${pkParam}'`
              };

              if ((trlParam != 'None') && trlParam){
                inputTRAIL.value = trlParam;
                trlquery = `DIST_TRAIL <= '${trlParam}'`
              };

              if ((logOpParam != 'None') && logOpParam){
                if (logOpParam === "And"){
                  andButton.click()
                }
                if (logOpParam === "Or"){
                  orButton.click()
                }
                logicOperator = logOpParam;
              };

              generateFullQuery();
              [PointsLayer, ParcelsLayer].forEach((layer) => { 
                // layer.definitionExpression = fullQuery;
                view.whenLayerView(layer).then((layerView) => {
                layerView.filter = {where: fullQuery};
              });
            });
              

              let pt = new Point({
                x: xParam,
                y: yParam,
                spatialReference: {
                  wkid: 3857
                }
              });

              // override center and zoom
              view.center = pt;
              view.zoom = zoomParam;

              if (geomParam === 'pcl'){
                ParcelsLayer.visible = true;
                PointsLayer.visible = false;
              } if (geomParam === 'pt'){
                ParcelsLayer.visible = false;
                PointsLayer.visible = true;
              }
            }
          } 
        });
        
        // Create URL params by watching when the extent is changed
        reactiveUtils.when(() => view.stationary === true, () => {
          // Get the new center of the view only when view is stationary.
          if (view.center) {
            // lat = view.center.latitude.toFixed(3)
            // lon = view.center.longitude.toFixed(3)
            x = view.center.x.toFixed(0)
            y = view.center.y.toFixed(0)
            zoom = view.zoom
            scale = view.scale
           
            // newURL = new URL(providedURL);
            
            if (ParcelsLayer.visible === true){newURL.searchParams.set("geom", 'pcl');};
            if (PointsLayer.visible === true){newURL.searchParams.set("geom", 'pt');};
            newURL.searchParams.set("x", x);
            newURL.searchParams.set("y", y);
            newURL.searchParams.set("zoom", zoom);
       
            var searchParams = newURL.searchParams;
            if (searchParams && searchParams.keys().next().done === false) {
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
            // console.log(newURL.href)
            }
          }
        });

        

      });

    </script>
  </head>

  <body>
    <div id="info" >
      <div id="title" style="flex:1.4;" >Housing Inventory Explorer (Jan 2022)</div>
      
      <div id="title" style="flex:1;">
        <a href="https://wfrc.org/">
          <img src="images/logo.png"  height="45px" width="auto">
        </a>
      </div>
    </div>
    <div id="viewDiv"></div>
    <div id="timeSlider"></div>

    <div id="sidebarDiv">    
      <div class="sbContainer1">
          <div id="sbHeader" class="sbItem">Selection Filters</div>
          <div class="sbItem"></div>
          <div class="sbItemHeader">County</div>
          <div class="sbItem"><calcite-select id="countySelect"></calcite-select> </div>
          <div class="sbItemHeader">City</div>
          <div class="sbItem"><calcite-select id="citySelect"></calcite-select></div>
          <div class="sbItemHeader">Center Name</div>
          <div class="sbItem"><calcite-select id="centerSelect"></calcite-select></div>
          <div class="sbItemHeader">Center Type</div>
          <div class="sbItem"><calcite-combobox id="centerTypeSelect" placeholder="select center types" selection-display="single" selection-mode="multiple"></calcite-combobox></div>
          <div class="sbItemHeader">Housing Type</div>
          <div class="sbItem"><calcite-combobox id="subtypeSelect" placeholder="select housing types" selection-display="single" selection-mode="multiple"></calcite-combobox></div>
      </div>
      <br style="line-height: 6px" >
      <div class="sbContainer2">
          <div id="sbHeader" class="sbItem">Buffer Filters</div>
          <div class="sbItem">
              <div  class="logicDiv">
                <div class="child4">
                  use:
                </div>
                <div class="child4">
                  <input id="andButton" type="button" value="Match All" class="esri-button" style="background-color: #00619B;"/>
                </div>
                <div class="child4">
                  <input id="orButton" type="button" value="Match Any" class="esri-button" style="background-color: #797979;"/>
                </div>
              </div>
          </div>
          <div class="sbItemHeader">TRAX/S-Line</div>
          <div class="sbItem"><calcite-input id="inputLR" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance (mi)"></calcite-input></div>
          <div class="sbItemHeader">FrontRunner</div>
          <div class="sbItem"><calcite-input id="inputFR" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance (mi)"></calcite-input></div>
          <div class="sbItemHeader">BRT</div>
          <div class="sbItem"><calcite-input id="inputBRT" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance (mi)"></calcite-input></div>
          <div class="sbItemHeader">Freeway Exit</div>
          <div class="sbItem"><calcite-input id="inputFWYE" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance (mi)"></calcite-input></div>
          <div class="sbItemHeader">Parks</div>
          <div class="sbItem"><calcite-input id="inputPARK" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance (mi)"></calcite-input></div>
          <div class="sbItemHeader">Trails/TH</div>
          <div class="sbItem"><calcite-input id="inputTRAIL" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance (mi)"></calcite-input></div>
      </div>
      <br style="line-height: 6px" >
      <div id="resetDiv">
        <input id="resetButton" type="button" value="Clear All Filters" class="esri-button" style="width:60%;background-color: #00619B;"/>
      </div>
    </div>

    

    <div id="infoDiv" class="esri-widget" >
      <h4 class="esri-widget__heading esri-editor__title" style="text-align:center">About this Application:</h4>
      <div class="esri-widget">
        <p>This map highlights the basic types and quantities of existing housing in Davis, Salt Lake and Weber counties.</p>
        <p> WFRC uses the County Assessor <a href="https://gis.utah.gov/data/cadastre/parcels/"> tax parcel GIS data</a> gathered annually by UGRC as a key input to its land use models and forecasts.</p>
        <p>The Housing Unit Inventory shown in this webmap is derived from January 1, 2022 residential data from the Assessor’s tax parcels, adding in unit count estimates for rental properties and grouping housing units together that share adjoining ‘common areas’ (e.g. condos and HOAs).</p>
        <p>For more information about this dataset, consult our <a href="https://docs.google.com/document/d/1W-ZdTamoB-rMPg91OTFyEO3OlI5LE0Vq7meF3oKFgVM/edit">metadata</a> or contact <a href="mailto:analytics@wfrc.org"> analytics@wfrc.org</a>.</p>
        <br>
        <h4 class="esri-widget__heading esri-editor__title" style="text-align:center">How to use:</h4>
        <p>Each panel can be toggled on or off. The Chart panel updates on the fly using whatever data is visible on the map. The Basemap can be switched to a variety of options and a legend can also be toggled. When zoomed in close enough, you can click a feature on the map to show its attributes. </p>
        <p>The Filters panel (top-left) allows you filter the data by geographic extent (Counties, Cities, or Wasatch Choice Centers). It also allows you to filter the units by their proximity to transit stations and/or freeway exits. You can use the And/Or button to change the query logic for these categories. Finally, you can filter the data by year, using the hidden time slider in the bottom-left. </p>
        
      </div>
    </div>

    <div id="resultDiv" class="esri-widget">
      
      <div>
        Total Units in View:
        <div class="count" id="countDiv">0</div>
      </div>

      <br>

      <div class="section">
        <canvas id="year-chart" height="250" width="300"></canvas>
      </div>

      <br>
      <div class="section">
        <canvas id="type-chart" height="250" ></canvas>
      </div>
      
      <div class="section" >
        <p>These charts dynamically update according to the <b>visible</b> features in the map. Hover over an element in the chart to view its description.</p>
        

      </div>
    </div>


  </body>