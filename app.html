<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Housing Inventory Explorer</title>
    <script type="module" src="https://js.arcgis.com/calcite-components/1.9.2/calcite.esm.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/1.9.2/calcite.css"/>
    <!-- Load the Chart.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js"></script>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css" />
    <script src="https://js.arcgis.com/4.28/"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
      html,
      body,

      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }

      #timeSlider {
        position: absolute;
        width: 190vh;
        left: 5%;
        right: 5%;
        bottom: 0px;
      }

      #info {
        z-index: 99;
        position: absolute;
        top: 15px;
        left: 0;
        right: 0;
        text-align: center;
        padding: 10px 15px 5px 15px;
        margin-left: auto;
        margin-right: auto;
        width: 25%;
        background: rgba(255, 255, 255, .9);
        font-size: 25pt;
        border: 2px solid #5a5a5a;
      }

      #titleText {
        font-size: 16pt;
        font-weight: 500;
      }

      #topbar {
        background: #fff;
        padding: 10px;
      }

      #infoDiv {
        padding: 10px;
        width: 320px;
        height: 420px;
        font-size: 14px;
        overflow-y: auto;
        overflow-x: hidden;
      }

      #instructionsDiv{
        width: 240px;
        padding: 10px;
        height: 300px;
        /* margin-top: 2000px; */
      }

      #sidebarDiv {
        height:70vh;
        width: 250px;
        padding: 10px;
        overflow-y: auto;
        border: 2px solid #5a5a5a;
        background: rgba(255, 255, 255, .9);
      }

      #resultDiv {
        display:flex;
        flex-direction: column;
        height:80vh;
        width: 40vh;
        font-size: 14px;
        padding: 10px;
        overflow-y: auto;
        overflow-x: hidden;
        background: rgba(255, 255, 255, .9);
        border: 2px solid #5a5a5a;
      }

      .section {
      flex: 1;
      /* position: relative; */
      /* border: 1px solid #ccc; */
      /* box-sizing: border-box; */
      }

      .count {
        flex: 1;
        white-space: nowrap;
        font-size: 14px;
        font-weight: bold;
        display: inline-block;
      }
      


    </style>

    <script>

      // read in a local json
      function fetchLocalJsonArray(filePath) {
        return fetch(filePath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .catch(error => {
            console.error('Error reading JSON file:', error);
          });
      }

      // populate a select box
      function populateSelectBox(selectName, array) {
        const selectBox = document.getElementById(selectName);

        // Clear existing options
        selectBox.innerHTML = '';

        // Populate with options from the array
        array.forEach(item => {
          const option = document.createElement('option');
          // option.value = item.value;  // Set the value attribute if needed
          option.text = item;    // Set the text content of the option
          selectBox.appendChild(option);
        });
      }
      
      // populate a combobox
      function populateComboBox (comboBoxName, array) {
          const comboBox = document.getElementById(comboBoxName);

          // Populate with options from the array
          array.forEach(item => {
            const comboItem  = document.createElement('calcite-combobox-item');
            // option.value = item.value;  // Set the value attribute if needed
            comboItem.setAttribute('value', item)
            comboItem.setAttribute('text-label', item)
            comboBox.appendChild(comboItem);
        });
      }


      require(["esri/config",
               "esri/Map", 
               "esri/geometry/Point",
               "esri/layers/FeatureLayer", 
               "esri/views/MapView", 
               "esri/widgets/Legend",
               "esri/widgets/TimeSlider",
               "esri/widgets/Expand",
               "esri/widgets/BasemapGallery",
               "esri/core/reactiveUtils"], (
        esriConfig,
        Map,
        Point,
        FeatureLayer,
        MapView,
        Legend,
        TimeSlider,
        Expand,
        BasemapGallery,
        reactiveUtils,
        
      ) => {

        esriConfig.apiKey = "AAPK5915b242a27845f389e0a11a17dc46b46gXNFj09FJVdb711lVLGhgoVFJBqdW6ow3bl71N1hx2llpMyogGBeF8kgvrKm3cY";

        // store the base url
        const providedURL =  window.location;
        const urlParamsToggle = true;

        // store paths to jsons
        const jsonBase = 'json/BASE.json';
        const jsonCounty = 'json/COUNTY.json';
        const jsonCity = 'json/CITY.json';
        const jsonCenter = 'json/CENTER.json';
        const jsonType = 'json/TYPE.json';
        
        let activeLayer;

        // initialize geographic filter options
        fetchLocalJsonArray(jsonBase)
        .then(data => {
          const countyArray = data[0].COUNTY;
          const cityArray = data[0].CITY;
          const centerArray = data[0].CENTER;
          populateSelectBox('countySelect', countyArray);
          populateSelectBox('citySelect', cityArray);
          populateSelectBox('centerSelect', centerArray);
        });

        // initialize housing type options
        fetchLocalJsonArray(jsonType)
        .then(data => {
          const subtypeArray = data[0].SUBTYPE;
          populateComboBox('subtypeSelect', subtypeArray);
        });


        // arcade functions used to modify text in the popup window
        const arcadeExpressionInfos = [
                {
                  name: "capitalize-subtype-arcade",
                  title: "Subtype",
                  expression: "Proper($feature.SUBTYPE)"
                },
                {
                  name: "format-type-arcade",
                  title: "Type",
                  expression: "Proper(Replace($feature.TYPE, '_', ' '))"
                }
              ];

        // renderer used to setup the symbolizaton of the housing layers
        const parcelTransparency = .5;
        const parcelRenderer = {
                    type: "unique-value",
                    legendOptions: {
                        title: "Housing Type"
                    },
                    field: "SUBTYPE",
                    uniqueValueInfos: [{
                        value: "single_family",
                        label: "Single Family",
                        symbol: {
                            type: "simple-fill",
                            color: [250, 236, 167, parcelTransparency], // [R,G,B, Transparency]
                        }
                    }, {
                        value: "duplex",
                        label: "Duplex",
                        symbol: {
                            type: "simple-fill",
                            color: [252, 146, 31, parcelTransparency]
                        }
                    }, {
                        value: "single_family_adu",
                        label: "Single Family ADU",
                        symbol: {
                            type: "simple-fill",
                            color: [230, 0, 73,parcelTransparency]
                        }
                    }, {
                        value: "townhome",
                        label: "Townhome",
                        symbol: {
                            type: "simple-fill",
                            color: [40, 200, 48,parcelTransparency]
                        }
                    }, {
                        value: "condo",
                        label: "Condo",
                        symbol: {
                            type: "simple-fill",
                            color: [158, 85, 156,parcelTransparency]
                        }
                    }, {
                        value: "mobile_home_park",
                        label: "Mobile Home Park",
                        symbol: {
                            type: "simple-fill",
                            color: [91, 73, 196,parcelTransparency]
                        }
                    }, {
                        value: 'mixed th/single_family',
                        label: "Townhome/Single Family",
                        symbol: {
                            type: "simple-fill",
                            color: [30, 133, 83,parcelTransparency]
                        }
                    }, {
                        value: "apartment",
                        label: "Apartment",
                        symbol: {
                            type: "simple-fill",
                            color: [20, 158, 206,parcelTransparency]
                        }
                    }]
                  };
                  
            // renderer used to setup the symbolizaton of the housing layers
            dPixelSize = "6px"
            dOutlineWidth = 1
            transparency = 1
            PtOutlineColor = [40,40,40]

            const pointRenderer = {
                    type: "unique-value",
                    legendOptions: {
                        title: "Housing Type"
                    },
                    field: "SUBTYPE",
                    uniqueValueInfos: [{
                        value: "single_family",
                        label: "Single Family",
                        symbol: {
                          type: "simple-marker",
                          color: [250, 236, 167, transparency], // [R,G,B, Transparency]
                          size: dPixelSize,
                          outline: {
                            color: PtOutlineColor,
                            width: dOutlineWidth
                        }
                      }
                    }, {
                        value: "duplex",
                        label: "Duplex",
                        symbol: {
                            type: "simple-marker",
                            color: [252, 146, 31, transparency],
                            size: dPixelSize,
                            outline: {
                              color: PtOutlineColor,
                              width: dOutlineWidth
                          }
                        }
                    }, {
                        value: "single_family_adu",
                        label: "Single Family ADU",
                        symbol: {
                            type: "simple-marker",
                            color: [230, 0, 73, transparency],
                            size: dPixelSize,
                            outline: {
                              color: PtOutlineColor,
                              width: dOutlineWidth
                          }
                        }
                    }, {
                        value: "townhome",
                        label: "Townhome",
                        symbol: {
                            type: "simple-marker",
                            color: [40, 200, 48, transparency],
                            size: dPixelSize,
                            outline: {
                              color: PtOutlineColor,
                              width: dOutlineWidth
                          }
                        }
                    }, {
                        value: "condo",
                        label: "Condo",
                        symbol: {
                            type: "simple-marker",
                            color: [158, 85, 156, transparency],
                            size: dPixelSize,
                            outline: {
                              color: PtOutlineColor,
                              width: dOutlineWidth
                          }
                        }
                    }, {
                        value: "mobile_home_park",
                        label: "Mobile Home Park",
                        symbol: {
                            type: "simple-marker",
                            color: [91, 73, 196, transparency],
                            size: dPixelSize,
                            outline: {
                              color: PtOutlineColor,
                              width: dOutlineWidth
                          }
                        }
                    }, {
                        value: 'mixed th/single_family',
                        label: "Townhome/Single Family",
                        symbol: {
                            type: "simple-marker",
                            color: [30, 133, 83, transparency],
                            size: dPixelSize,
                            outline: {
                              color: PtOutlineColor,
                              width: dOutlineWidth
                          }
                        }
                    }, {
                        value: "apartment",
                        label: "Apartment",
                        symbol: {
                            type: "simple-marker",
                            color: [20, 158, 206, transparency],
                            size: dPixelSize,
                            outline: {
                              color: PtOutlineColor,
                              width: dOutlineWidth
                          }
                        }
                    }]
                  };

        

        const ParcelsLayer = new FeatureLayer({
            outFields: ["*"],
            url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/hui_for_web_gdb/FeatureServer/0",
            renderer:parcelRenderer,
            maxScale: 0,
            visible: false
          });
        
        const PointsLayer = new FeatureLayer({
            url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/hui_for_web_gdb/FeatureServer/1",
            renderer:pointRenderer,
            outFields: ["*"],
            visible: true
          });


        // Create the Map and View objects
        const defaultZoom = 10
        const map = new Map({
          basemap: "satellite",
          layers: [PointsLayer, ParcelsLayer],
        });

        const view = new MapView({
          container: "viewDiv",
          map: map,
          zoom: defaultZoom,
          center: [-111.98, 40.94]
        });

        if (providedURL.href.includes('?') === false) {
          activeLayer = PointsLayer;
        }

        // view.ui.move("zoom", "top-right");


        // create the base map gallery expand object
        const basemapGallery = new BasemapGallery({
                view: view,
                container: document.createElement("div")
              });

        // Create an Expand instance and set the content
        // property to the DOM node of the basemap gallery widget
        // Use an Esri icon font to represent the content inside
        // of the Expand widget
        const bgExpand = new Expand({
          expandTooltip: "Basemap",
          view: view,
          content: basemapGallery,
          group: "top-right"
        });

        // add the wind rose chart div
        const infoDiv = document.getElementById("infoDiv");
        const infoDivExpand = new Expand({
          expandIcon: "information",
          expandTooltip: "Info",
          view,
          content: infoDiv,
          expanded: false,
          group: "top-right"
        });
        
      

        // close the expand whenever a basemap is selected
        // on mobile devices
        reactiveUtils.watch(
          () => basemapGallery.activeBasemap,
          () => {
            const mobileSize = view.heightBreakpoint === "xsmall" || view.widthBreakpoint === "xsmall";

            if (mobileSize) {
              bgExpand.collapse();
            }
          }
        );

        // Add the expand instance to the ui
        view.ui.add(infoDivExpand, "top-right");
        view.ui.add(bgExpand, "top-right");

        view.when(() => {
                // get the first layer in the collection of operational layers in the WebMap
                // when the resources in the MapView have loaded.
                const legend = new Legend({
                  view: view,
                  layerInfos: [
                    {
                      layer: PointsLayer,
                      title: ""
                    },
                    {
                      layer: ParcelsLayer,
                      title: ""
                    }
                  ]
                });

                const legendExpand = new Expand({
                expandIcon: "legend",
                expandTooltip: "Legend",
                view: view,
                content: legend,
                group: "top-right"
                });

                // Add widget to the bottom right corner of the view
                view.ui.add(legendExpand, "top-right");
              });
        
        
        // when the view object is created, create a time slider
        view.when(() => {
                    timeSlider = new TimeSlider({
                      container: "timeSlider",
                      view: view,
                      // full min max of time slider
                      fullTimeExtent: { 
                        start: new Date(1850, 0, 1),
                        end: new Date(2022, 0, 1)
                      },
                      // starting min max of time slider
                      timeExtent:{ 
                        start: new Date(1850, 0, 1),
                        end: new Date(2022, 0, 1)
                      },
                      // play speed, not needed?
                      playRate: 2000, 
                      stops: {
                        interval: {
                          value: 1,
                          unit: "years"
                        }
                      },
                      
                      // set custom labels for the timeslider's min, max, and extent dates
                      labelFormatFunction: (value, type, element, layout) => {
                        const options = {year: 'numeric'}
                        const normal = new Intl.DateTimeFormat("en-us", options);
                        switch (type) {
                          case "min":
                            element.setAttribute("style", "color: #ff642e;");
                            element.innerText = normal.format(value);
                            break;
                          case "max":
                            element.setAttribute("style", "color: #ff642e;");
                            element.innerText = normal.format(value);
                            break;
                          case "extent":
                            const year0 = value[0].getFullYear();
                            const year1 = value[1].getFullYear()
                            element.innerText = `Year Built:
                            ${year0} - ${year1}`;
                            break;
                        }
                      }
                    });
                  

                  // Option 1: time slider expand
                  const timeSliderExpand = new Expand({
                      expandIcon: "calendar",
                      expandTooltip: "TimeSlider",
                      view,
                      content: timeSlider.container,
                      expanded: false
                    });
                  
                  view.ui.add(timeSliderExpand, "bottom-left");


                  // Option 2: add the time slider (non-expandable) to the view, manual allows for div placement
                  // view.ui.add(timeSlider, "manual");
                });
        
        // store ui objects as variables
        const countySelect = document.getElementById("countySelect");
        const citySelect = document.getElementById("citySelect");
        const centerSelect = document.getElementById("centerSelect");
        const subtypeSelect = document.getElementById("subtypeSelect");
        const resetButton1 = document.getElementById("resetButton1");
        
        // define default queries
        const defaultCountyQuery = "(COUNTY IS NULL OR COUNTY IS NOT NULL)";
        const defaultCityQuery = "(CITY IS NULL OR CITY IS NOT NULL)";
        const defaultCenterQuery = "(CENTER IS NULL OR CENTER IS NOT NULL)";

        const defaultSubtypeQuery = "(SUBTYPE IS NULL OR SUBTYPE IS NOT NULL)";

        const defaultLRquery = "(DIST_LR IS NULL OR DIST_LR IS NOT NULL)";
        const defaultFRquery = "(DIST_FR IS NULL OR DIST_FR IS NOT NULL)";
        const defaultBRTquery = "(DIST_BRT IS NULL OR DIST_BRT IS NOT NULL)";
        const defaultFWYEquery = "(DIST_FWYE IS NULL OR DIST_FWYE IS NOT NULL)";

        // set initial selection for geography filters - could switch to a placeholder?
        let countySelectionCurrent = "-No Selection-";
        let citySelectionCurrent = "-No Selection-";
        let centerSelectionCurrent = "-No Selection-";

        let countyQuery = defaultCountyQuery;
        let cityQuery = defaultCityQuery;
        let centerQuery = defaultCenterQuery;
        let subtypeQuery = defaultSubtypeQuery;

        let LRquery = defaultLRquery;
        let FRquery = defaultFRquery;
        let BRTquery = defaultBRTquery;
        let FWYEquery = defaultFWYEquery;

        let fullQuery = null;

        function generateFullQuery() {
          fullQuery = countyQuery + ' AND ' + cityQuery + ' AND ' + centerQuery + ' AND ' + subtypeQuery + ' AND ' + LRquery + ' AND ' + FRquery + ' AND ' + BRTquery + ' AND ' + FWYEquery ;
        }

         // define initial definition expression
        const initialDefinitionExpression = generateFullQuery()

        // setup actions for the reset button
        resetButton1.addEventListener("click", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => {
            
            // clear the definition expression
            layer.definitionExpression = null;
            
            fetchLocalJsonArray(jsonBase)
            .then(data => {
              
              const countyArray = data[0].COUNTY;
              const cityArray = data[0].CITY;
              const centerArray = data[0].CENTER;
              populateSelectBox('countySelect', countyArray);
              populateSelectBox('citySelect', cityArray);
              populateSelectBox('centerSelect', centerArray);
            });

            countyQuery = defaultCountyQuery; // work for now but should the select just be set to null instead?
            cityQuery = defaultCityQuery;
            centerQuery = defaultCenterQuery;
            subtypeQuery = defaultSubtypeQuery;

            subtypeSelect.value = null;
            inputLR.value = null;
            inputFR.value = null;
            inputBRT.value = null;
            inputFWYE.value = null;

            // reset the url
            var baseUrl = providedURL.origin + providedURL.pathname;
            console.log(baseUrl)
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', baseUrl);
          });
        });


        // COUNTY - filter and zoom features, update select options
        countySelect.addEventListener("change", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selectionText = countySelect.options[countySelect.selectedIndex].text;
            countySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "-No Selection-"){
              countyQuery = defaultCountyQuery
            }else{
              countyQuery = `COUNTY = '${selectionText}'`
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCounty)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

              populateSelectBox('countySelect', countyArray);
              populateSelectBox('citySelect', cityArray);
              populateSelectBox('centerSelect', centerArray);

              countySelect.value = countySelectionCurrent;
              citySelect.value = citySelectionCurrent;
              centerSelect.value = centerSelectionCurrent;
            });
          });
          PointsLayer.queryExtent().then((results) => {
            view.goTo(results.extent);
          });
        });

        // CITY - filter and zoom features, update select options
        citySelect.addEventListener("change", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selectionText = citySelect.options[citySelect.selectedIndex].text;
            citySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "-No Selection-"){
              cityQuery = defaultCityQuery
            }else{
              cityQuery = `CITY = '${selectionText}'`
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCity)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

              populateSelectBox('countySelect', countyArray);
              populateSelectBox('citySelect', cityArray);
              populateSelectBox('centerSelect', centerArray);

              countySelect.value = countySelectionCurrent;
              citySelect.value = citySelectionCurrent;
              centerSelect.value = centerSelectionCurrent;
            });
          });
          PointsLayer.queryExtent().then((results) => {
            view.goTo(results.extent);
          });
        });

        // CENTER - filter and zoom features, update select options
        centerSelect.addEventListener("change", () => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selectionText = centerSelect.options[centerSelect.selectedIndex].text;
            centerSelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "-No Selection-"){
              centerQuery = defaultCenterQuery
            }else{
              centerQuery = `CENTER = '${selectionText}'`
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCenter)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

              populateSelectBox('countySelect', countyArray);
              populateSelectBox('citySelect', cityArray);
              populateSelectBox('centerSelect', centerArray);

              countySelect.value = countySelectionCurrent;
              citySelect.value = citySelectionCurrent;
              centerSelect.value = centerSelectionCurrent;
            });
          });
          PointsLayer.queryExtent().then((results) => {
            view.goTo(results.extent);
          });
        });

        // SUBTYPE Select
        subtypeSelect.addEventListener("calciteComboboxChange", (event) => {
          [PointsLayer, ParcelsLayer].forEach((layer) => { // fix this to include parcels and points in main app


            selection = event.target.value;
            // console.log(selection);

            if (Array.isArray(selection) == false){
              if(selection === null | selection === " " | selection === ""){
                subtypeQuery = defaultSubtypeQuery
              }else{
                subtypeQuery = `SUBTYPE IN ('${selection}')`
              }
            }else{
              selection = selection.map(value => `'${value}'`);
              subtypeQuery = `SUBTYPE IN (${selection})`
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
          });
        });


        

        //initialize light rail dist filter
        const inputLR  = document.getElementById("inputLR");
        inputLR.value = null;
        inputLR.addEventListener("calciteInputChange", function(){

            userInput = inputLR.value;
            console.log(typeof(userInput))

            if (userInput === null | userInput === " " | userInput === ""){
              LRquery = defaultLRquery;
            }  else {
              LRquery = `DIST_LR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });


        //initialize frontrunner dist filter
        const inputFR  = document.getElementById("inputFR");
        inputFR.value = null;
        inputFR.addEventListener("calciteInputChange", function(){

            userInput = inputFR.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              FRquery = defaultFRquery;
            }  else {
              FRquery = `DIST_FR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        //initialize BRT dist filter
        const inputBRT  = document.getElementById("inputBRT");
        inputBRT.value = null;
        inputBRT.addEventListener("calciteInputChange", function(){

            userInput = inputBRT.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              BRTquery = defaultBRTquery;
            }  else {
              BRTquery = `DIST_BRT <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        //initialize FWYE dist filter
        const inputFWYE  = document.getElementById("inputFWYE");
        inputFWYE.value = null;
        inputFWYE.addEventListener("calciteInputChange", function(){

            userInput = inputFWYE.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              FWYEquery = defaultFWYEquery;
            } else {
              FWYEquery = `DIST_FWYE <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [PointsLayer, ParcelsLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        // Add an event listener for the zoom change
        view.watch("zoom", function (newZoom) {
          console.log("Zoom level changed to: ", newZoom);

          if (newZoom >= 15){ 
            ParcelsLayer.visible = true;
            PointsLayer.visible = false;
            activeLayer = ParcelsLayer;
          }
          else if (newZoom < 15 && newZoom > 5){ 
            ParcelsLayer.visible = false;
            PointsLayer.visible = true;
            activeLayer = PointsLayer;
          }
        });

        view.ui.add("sidebarDiv", { position: "top-left"});

      //=========================
      // chart stuff
      //=========================

      let yearChart = null;
      let typeChart = null;

      const yearCanvas = document.getElementById("year-chart");
      const typeCanvas = document.getElementById("type-chart");


      function queryStatisticsForYearChart() {


          yearChart.options.title.text = "Built Decade (Loading...)"
          yearChart.update();
    
          // create query definitions for stacked bar chart data
          const decades = ["1840", "1850", "1860", "1870", "1880", "1890", "1900", "1910", "1920", "1930", "1940", "1950", "1960", "1970", "1980", "1990", "2000", "2010", "2020"];
          const subtypes = ["single_family", "duplex", "single_family_adu", "condo", "townhome", "mobile_home_park", "mixed_th/single_family", "apartment"];
          const yearChartDefinitions = [];
          for (const decade of decades) {
            for (const subtype of subtypes) {
              const definition = {
                onStatisticField: `CASE WHEN (BLT_DECADE = '${decade}' AND SUBTYPE = '${subtype}') THEN UNIT_COUNT ELSE 0 END`,
                outStatisticFieldName: `year_${decade}_${subtype}`,
                statisticType: "sum"
              };

              yearChartDefinitions.push(definition);
            }
          }

          // query for stacked bar chart data
          const yearChartQuery = activeLayer.createQuery();
          yearChartQuery.geometry = view.extent;
          yearChartQuery.outStatistics = yearChartDefinitions;

          return activeLayer.queryFeatures(yearChartQuery).then((result) => {
            const yearChartQueryResult = result.features[0].attributes;
            // console.log(yearChartQueryResult)

            
            const decadeTypeCountArray = [];
            for (const property in yearChartQueryResult) {
              if (yearChartQueryResult.hasOwnProperty(property)) {
                const [year, ...typeParts] = property.split('_').slice(1);

                decadeTypeCountArray.push({
                  decade: +year,
                  type: typeParts.join('_'),
                  count: yearChartQueryResult[property]
                });
              }
            }
            // console.log(decadeTypeCountArray);


              // Calculate the sum of counts for each decade
              const decadeSums = decadeTypeCountArray.reduce((acc, entry) => {
                acc[entry.decade] = (acc[entry.decade] || 0) + entry.count;
                return acc;
              }, {});

              // Filter out objects with a sum of 0 and get an array of unique decades
              const filteredArray = decadeTypeCountArray.filter(entry => decadeSums[entry.decade] !== 0);
              const uniqueDecades = [...new Set(filteredArray.map(entry => entry.decade))];
              // console.log(uniqueDecades);
              
              // create data objects for each housing type
              const stackedChartDataObjects = [];
              const typeData = {};
              for (const entry of filteredArray) {
                const { type, count, decade } = entry;

                if (!typeData[type]) {
                  typeData[type] = {
                    label: type,
                    data: [],
                    backgroundColor:null
                  };
                }
                typeData[type].data.push(count);

                // If the decade is not already added to the data object, add it
                if (typeData[type].data.length === 1) {
                  typeData[type].decade = decade;
                }
              }
              // Convert the object values to an array
              for (const type in typeData) {
                if (typeData.hasOwnProperty(type)) {
                  stackedChartDataObjects.push(typeData[type]);
                }
              }
              // console.log(stackedChartDataObjects);

              // Update the backgroundColor attribute using the typeColorMap
              const typeColorMap = {
                "single_family": '#FAECA7',
                "duplex": '#FC921F',
                "single_family_adu": '#E60049',
                "condo": '#BD7EBE',
                "townhome": '#28C830',
                "mobile_home_park": '#9E559C',
                "mixed_th/single_family": '#1E8553',
                "apartment": '#149ECE'
              };
              
              const updatedDataArray = stackedChartDataObjects.map(item => ({
                ...item,
                backgroundColor: typeColorMap[item.label]
              }));

              // console.log(updatedDataArray);
              yearChart.options.title.text = "Built Decade"
              yearChart.update();

              updateStackedChart(yearChart, uniqueDecades,updatedDataArray)
          
          }, console.error);

        }

        function queryStatisticsForTypeChart() {
          
          typeChart.options.title.text = "Housing Type (Loading...)"
          typeChart.update();

          const statDefinitions = [
            {
              onStatisticField: "CASE WHEN SUBTYPE IS NOT NULL THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "total",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'single_family' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "single_family",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'duplex' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "duplex",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'single_family_adu' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "single_family_adu",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'townhome' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "townhome",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'condo' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "condo",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'mobile_home_park' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "mobile_home_park",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'mixed th/single_family' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "mixed_th_single_family",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN SUBTYPE = 'apartment' THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "apartment",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1840') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1840",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1850') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1850",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1860') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1860",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1870') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1870",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1880') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1880",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1890') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1890",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1900') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1900",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1910') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1910",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1920') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1920",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1930') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1930",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1940') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1940",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1950') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1950",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1960') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1960",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1970') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1970",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1980') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1980",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '1990') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_1990",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2000') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2000",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2010') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2010",
              statisticType: "sum"
            },
            {
              onStatisticField: "CASE WHEN (BLT_DECADE = '2020') THEN UNIT_COUNT ELSE 0 END",
              outStatisticFieldName: "year_2020",
              statisticType: "sum"
            } 
          ];
           
          // query data for the pie chart
          const query = activeLayer.createQuery();
          query.geometry = view.extent;
          query.outStatistics = statDefinitions;
          return activeLayer.queryFeatures(query).then((result) => {
            const allStats = result.features[0].attributes;
            document.getElementById("count").innerHTML = allStats.total;
          
            typeChart.options.title.text = "Housing Type"
            typeChart.update();

            updateChart(typeChart, [
              allStats.single_family,
              allStats.duplex,
              allStats.single_family_adu,
              allStats.condo,
              allStats.townhome,
              allStats.mobile_home_park,
              allStats.mixed_th_single_family,
              allStats.apartment
            ]);

          }, console.error);
        }

        // Updates the given chart with new data
        function updateChart(chart, dataValues) {
          chart.data.datasets[0].data = dataValues;
          chart.update();
        }

        // Updates the given chart with new data
        function updateStackedChart(chart, labels, dataValues) {
          chart.data.labels = labels;
          chart.data.datasets = dataValues;
          chart.update();
        }

        // instantiate the year stacked chart
        function createYearChart() {
          // const yearCanvas = document.getElementById("year-chart");
          yearChart = new Chart(yearCanvas.getContext("2d"), {
            type: "bar",
            data: {
              labels: [],
              datasets: [
                {
                  label: null,
                  backgroundColor: "#149dcf",
                  data: []
                }
              ]
            },
            options: {
              // responsive: false,
              legend: {
                display: false
              },
              title: {
                display: true,
                text: "Built Decade"
              },
              scales: {
                xAxes: [
                  {
                    stacked: true,
                    ticks: {
                      beginAtZero: true,
                      precision: 0
                    }
                  }
                ],
                yAxes: [
                  {
                    stacked: true
                  }
                ]
              }
            }
          });
        }

        // instantiate the type pie chart
        function createTypeChart() {
          // const typeCanvas = document.getElementById("type-chart");
          typeChart = new Chart(typeCanvas.getContext("2d"), {
            type: "doughnut",
            data: {
              labels: ["single_family", "duplex", "single_family_adu", "condo", 
                       "townhome", "mobile_home_park", "mixed th/single_family", "apartment"],
              datasets: [
                {
                  backgroundColor: ["#FAECA7", "#FC921F", "#E60049", "#BD7EBE", 
                                    "#28C830", "#9E559C", '#1E8553', '#149ECE'],
                  borderWidth: 0,
                  data: [0, 0, 0, 0, 0, 0, 0, 0]
                }
              ]
            },
            options: {
              responsive: true,
              cutoutPercentage: 25,
              legend: {
                display:false,
                position: "top",
              },
              title: {
                display: true,
                text: "Housing Type"
              }
            }
          });
        }

        // create the charts
        createYearChart();
        createTypeChart();

        // when the extent is changed update the charts
        reactiveUtils.when(() => view.stationary === true, () => {
          
          
          queryStatisticsForYearChart();
          queryStatisticsForTypeChart();
        });

        const resultDiv = document.getElementById("resultDiv");
        const chartExpand = new Expand({
          expandIcon: "graph-bar-side-by-side",
          expandTooltip: "Statistics",
          view: view,
          content: resultDiv,
          expanded: true,
          group: "top-right"
        });

        view.ui.add(chartExpand, { position: "top-right"});
   


        //===============================
        // urlParams Functionality
        //===============================
        view.when(() => {
          // if provide URL has searchParams update the map
          if (urlParamsToggle === true){
            if (providedURL.href.includes('?') === true) {
              var newURL = new URL(providedURL)
              var searchParams = newURL.searchParams;
              var geomParam = searchParams.get("geom");

              var countyParam = searchParams.get("cny");
              var cityParam = searchParams.get("cty");
              var centerParam = searchParams.get("ctr");

              var xParam = parseInt(searchParams.get("x"));
              var yParam = parseInt(searchParams.get("y"));
              var zoomParam = parseInt(searchParams.get("zoom"));
              
              // if (countyParam != '-No Selection-'){countySelect.value = countyParam};
              // countySelect.dispatchEvent(new Event('change'));

              // if (cityParam != '-No Selection-'){citySelect.value = cityParam};
              // citySelect.dispatchEvent(new Event('change'));

              // if (centerParam != '-No Selection-'){centerSelect.value = centerParam};
              // centerSelect.dispatchEvent(new Event('change'));
    


              let pt = new Point({
                x: xParam,
                y: yParam,
                spatialReference: {
                  wkid: 3857
                }
              });

              // override center and zoom
              view.center = pt;
              view.zoom = zoomParam;

              if (geomParam === 'pcl'){
                ParcelsLayer.visible = true;
                PointsLayer.visible = false;
                activeLayer = ParcelsLayer;
              } if (geomParam === 'pt'){
                ParcelsLayer.visible = false;
                PointsLayer.visible = true;
                activeLayer = PointsLayer;
              }
            }
          } 
        });
        
        // Create URL params by watching when the extent is changed
        reactiveUtils.when(() => view.stationary === true, () => {
          // Get the new center of the view only when view is stationary.
          if (view.center) {
            // lat = view.center.latitude.toFixed(3)
            // lon = view.center.longitude.toFixed(3)
            x = view.center.x.toFixed(0)
            y = view.center.y.toFixed(0)
            zoom = view.zoom
            scale = view.scale
           
            newURL = new URL(providedURL);
            
            if (ParcelsLayer.visible === true){newURL.searchParams.set("geom", 'pcl');};
            if (PointsLayer.visible === true){newURL.searchParams.set("geom", 'pt');};
            newURL.searchParams.set("x", x);
            newURL.searchParams.set("y", y);
            newURL.searchParams.set("zoom", zoom);
            // if (countySelect.value !== '-No Selection-' | countySelect !== null | countySelect !== ''){newURL.searchParams.set("cny", countySelect.value);};
            // // newURL.searchParams.set("cny", countySelect.value);
            // if (citySelect.value !== '-No Selection-'){newURL.searchParams.set("cty", citySelect.value);};
            // if (centerSelect.value !== '-No Selection-'){newURL.searchParams.set("ctr", centerSelect.value);};

            var searchParams = newURL.searchParams;
            if (searchParams && searchParams.keys().next().done === false) {
            window.history.replaceState({ additionalInformation: 'Updated the URL with JS' }, 'Updated!', newURL);
            // console.log(newURL.href)
            }
          }
        });

        

      });

    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
    <div id="timeSlider"></div>

    <div id="info" class="esri-widget">
      <div id="titleText">Housing Unit Inventory Explorer (Jan 2022)</div>
    </div>

    <div id="sidebarDiv" class="esri-widget">
      
      <h4 class="esri-heading">Filter by County</h4>
      <select id="countySelect" class="esri-widget"  style="width: 200px;">
      </select>

      <h4 class="esri-heading">Filter by City</h4>
      <select id="citySelect" class="esri-widget"  style="width: 200px;">
      </select>

      <h4 class="esri-heading">Filter by Center</h4>
      <select id="centerSelect" class="esri-widget"  style="width: 200px;">
      </select>

      <h4 class="esri-heading">- - - - - - - - -</h4>
      
      <label>
        <b>Filter by Housing Type</b>
        <br><br>
        <calcite-combobox  id="subtypeSelect" placeholder="select housing types" style="width: 200px;">
        </calcite-combobox>
      </label>

      <h4 class="esri-heading">- - - - - - - - -</h4>
  
      <label>
        <b>Distance from TRAX (mi)</b>
        <br><br>
        <calcite-input id="inputLR" width="200px" type="number" step=.5 min=0 clearable=true placeholder="enter a distance"></calcite-input>
      </label>
      
      <br><br>
      
      <label>
        <b>Distance from Frontrunner (mi)</b>
        <br><br>
        <calcite-input id="inputFR" width="200px" type="number" step=.5 min=0 clearable=true placeholder="enter a distance"></calcite-input>
      </label>

      <br><br>

      <label>
        <b>Distance from BRT (mi)</b>
        <br><br>
        <calcite-input id="inputBRT" width="200px" type="number" step=.5 min=0 clearable=true placeholder="enter a distance"></calcite-input>
      </label>
      <br><br>
      <label>
        <b>Distance from FWY Exit (mi)</b>
        <br><br>
        <calcite-input id="inputFWYE" width="200px" type="number" step=.5 min=0 clearable=true placeholder="enter a distance"></calcite-input>
      </label>
      <br><br>
      <input id="resetButton1" type="button" value="Reset Filters" class="esri-button" style="width: 200px;" />
    </div>

    <div id="infoDiv" class="esri-widget">
      <h4 class="esri-widget__heading esri-editor__title">Summary</h4>
      <div class="esri-widget">
        <p>This map highlights the basic types and quantities of existing housing in Davis, Salt Lake and Weber counties. The filters below allow for a closer look at counties, cities, trends over time, and transit station and freeway distance buffers. </p>
        <p> WFRC uses the County Assessor <a href="https://gis.utah.gov/data/cadastre/parcels/"> tax parcel GIS data</a> gathered annually by UGRC as a key input to its land use models and forecasts.</p>
        <p>The Housing Unit Inventory shown in this webmap is derived from January 1, 2020 residential data from the Assessor’s tax parcels, adding in unit count estimates for rental properties and grouping housing units together that share adjoining ‘common areas’ (e.g. condos and HOAs).</p>
        <p>For more information about this dataset, consult our <a href="https://docs.google.com/document/d/1W-ZdTamoB-rMPg91OTFyEO3OlI5LE0Vq7meF3oKFgVM/edit">metadata</a> or contact <a href="mailto:analytics@wfrc.org"> analytics@wfrc.org</a>.</p>
      </div>
    </div>

    <div id="resultDiv" class="esri-widget">
      
      <div class="count">
        Total Units:
        <div class="count" id="count">0</div>
      </div>

      <div class="section">
        <canvas id="year-chart" height="250" width="300"></canvas>
        
      </div>

      <div class="section">
        <canvas id="type-chart" height="200" ></canvas>
        
      </div>
      
      <div class="section" id="chart-info" ></div>
        <p>These charts dynamically update  according to the <b>visible</b> features in the map.</p>
        

      </div>
    </div>


  </body>