<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Filter and Zoom 2</title>

    <script type="module" src="https://js.arcgis.com/calcite-components/1.9.2/calcite.esm.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.arcgis.com/calcite-components/1.9.2/calcite.css"/>

    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/dark/main.css" />
    <script src="https://js.arcgis.com/4.28/"></script>

    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }
      #sidebarDiv {
        width: 35vw;
        padding: 10px;
        height: 65vh;
        /* overflow-y: auto; */
        border: 2px solid #ccc;
        background-color: #323232;
      }

      #resetButton, #andButton, #orButton{
        color:white;
        
      }

      .grid-container {
        display: grid;
        grid-template-columns: repeat(2, 50%); /* Two columns with equal width */
        grid-gap: 2vh; /* Adjust the gap between grid items as needed */
      }
      .grid-container2 {
        display: grid;
        grid-template-columns: repeat(2, 50%);
        grid-gap: .5vh;
        
      }
      

      /* Style for each grid item */
      .grid-item {
        height: 10vh;
        width: 15vw;
        border: 1px solid #ccc;
        padding: 5px;
        text-align: center;
        /* white-space: normal; */
        font-size: 1vw;
        color:white;
      }

      /* Style for each grid item */
      .grid-item2 {
        height: 5vh;
        width: 15vw;
        border: 1px solid #ccc;
        padding: 5px;
        text-align: center;
        /* white-space: normal; */
        font-size: 1vw;
        color:white;
      }
      .child1 {
      height: 40%; 
      /* background-color: lightblue; */
      /* border: 1px solid #2305cc; */
      }
      .child2 {
        height: 60%; 
        /* background-color: rgb(192, 135, 13); */
        /* border: 1px solid #d80303; */
      }
      .child3 {
        height: 100%; 
        width: 100%;
        
        /* background-color: rgb(192, 135, 13); */
        /* border: 1px solid #d80303; */
      }
      .child4 {
        height: 100%; 
        width: 95%;
        /* border: 1px solid #d80303; */
      }


    </style>

    <script>
      function setCalciteSelectValue(selectElement, newValue) {
        // const selectElement = document.getElementById(selectId);
        
        // Find the option with the specified value
        const optionToSelect = Array.from(selectElement.children)
          .find(option => option.value === newValue);

        if (optionToSelect) {
          // Set the 'selected' attribute on the option
          optionToSelect.setAttribute('selected', '');

          // Dispatch a 'change' event to simulate user interaction
          const changeEvent = new Event('change', { bubbles: true });
          selectElement.dispatchEvent(changeEvent);
        }
      }


      function fetchLocalJsonArray(filePath) {
        return fetch(filePath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .catch(error => {
            console.error('Error reading JSON file:', error);
          });
      }

      function populateSelectBox(selectName, array) {
        const selectBox = document.getElementById(selectName);

        // Clear existing options
        selectBox.innerHTML = '';

        // Populate with options from the array
        array.forEach(item => {
          const option = document.createElement('calcite-option');
          // option.value = item.value;  // Set the value attribute if needed
          option.setAttribute('value', item)
          option.setAttribute('label', item)
          // option.text = item;    // Set the text content of the option
          selectBox.appendChild(option);
      });
    }

      function populateComboBox (comboBoxName, array) {
          const comboBox = document.getElementById(comboBoxName);

          // Populate with options from the array
          array.forEach(item => {
            const comboItem  = document.createElement('calcite-combobox-item');
            // option.value = item.value;  // Set the value attribute if needed
            comboItem.setAttribute('value', item)
            comboItem.setAttribute('text-label', item)
            comboBox.appendChild(comboItem);
        });
      }
    


      

      require(["esri/Map", "esri/layers/FeatureLayer", "esri/views/MapView"], (
        Map,
        FeatureLayer,
        MapView
      ) => {

      
      const jsonBase = 'json/BASE.json';
      const jsonCounty = 'json/COUNTY.json';
      const jsonCity = 'json/CITY.json';
      const jsonCenter = 'json/CENTER.json';
      const jsonType = 'json/TYPE.json';
      
      // initialize geographic filter options
      fetchLocalJsonArray(jsonBase)
      .then(data => {
        const countyArray = data[0].COUNTY;
        const cityArray = data[0].CITY;
        const centerArray = data[0].CENTER;
        populateSelectBox('countySelect', countyArray);
        populateSelectBox('citySelect', cityArray);
        populateSelectBox('centerSelect', centerArray);
      });

      // initialize housing type options
      fetchLocalJsonArray(jsonType)
      .then(data => {
        const subtypeArray = data[0].SUBTYPE;
        populateComboBox('subtypeSelect', subtypeArray);
      });

  

        // renderer used to setup the symbolizaton of the housing layers
        dPixelSize = "6px"
        dOutlineWidth = 1
        transparency = 1
        PtOutlineColor = [40,40,40]

        const pointRenderer = {
                type: "unique-value",
                legendOptions: {
                    title: "Housing Type"
                },
                field: "SUBTYPE",
                uniqueValueInfos: [{
                    value: "single_family",
                    label: "Single Family",
                    symbol: {
                      type: "simple-marker",
                      color: [250, 236, 167, transparency], // [R,G,B, Transparency]
                      size: dPixelSize,
                      outline: {
                        color: PtOutlineColor,
                        width: dOutlineWidth
                    }
                  }
                }, {
                    value: "duplex",
                    label: "Duplex",
                    symbol: {
                        type: "simple-marker",
                        color: [252, 146, 31, transparency],
                        size: dPixelSize,
                        outline: {
                          color: PtOutlineColor,
                          width: dOutlineWidth
                      }
                    }
                }, {
                    value: "single_family_adu",
                    label: "Single Family ADU",
                    symbol: {
                        type: "simple-marker",
                        color: [230, 0, 73, transparency],
                        size: dPixelSize,
                        outline: {
                          color: PtOutlineColor,
                          width: dOutlineWidth
                      }
                    }
                }, {
                    value: "townhome",
                    label: "Townhome",
                    symbol: {
                        type: "simple-marker",
                        color: [40, 200, 48, transparency],
                        size: dPixelSize,
                        outline: {
                          color: PtOutlineColor,
                          width: dOutlineWidth
                      }
                    }
                }, {
                    value: "condo",
                    label: "Condo",
                    symbol: {
                        type: "simple-marker",
                        color: [158, 85, 156, transparency],
                        size: dPixelSize,
                        outline: {
                          color: PtOutlineColor,
                          width: dOutlineWidth
                      }
                    }
                }, {
                    value: "mobile_home_park",
                    label: "Mobile Home Park",
                    symbol: {
                        type: "simple-marker",
                        color: [91, 73, 196, transparency],
                        size: dPixelSize,
                        outline: {
                          color: PtOutlineColor,
                          width: dOutlineWidth
                      }
                    }
                }, {
                    value: 'mixed th/single_family',
                    label: "Townhome/Single Family",
                    symbol: {
                        type: "simple-marker",
                        color: [30, 133, 83, transparency],
                        size: dPixelSize,
                        outline: {
                          color: PtOutlineColor,
                          width: dOutlineWidth
                      }
                    }
                }, {
                    value: "apartment",
                    label: "Apartment",
                    symbol: {
                        type: "simple-marker",
                        color: [20, 158, 206, transparency],
                        size: dPixelSize,
                        outline: {
                          color: PtOutlineColor,
                          width: dOutlineWidth
                      }
                    }
                }]
              };



        const housingLayer = new FeatureLayer({
                outFields: ["*"],
                url: "https://services1.arcgis.com/taguadKoI1XFwivx/arcgis/rest/services/hui_for_web_gdb/FeatureServer/1",
                renderer:pointRenderer
              });



        const map = new Map({
          basemap: "topo-vector",
          // layers: [statesFeatureLayer, countiesFeatureLayer]
          layers: [housingLayer]
        });

        const view = new MapView({
          container: "viewDiv",
          map: map,
          zoom: 16,
          center: [-111.8587166, 40.7665529]
        });

        view.ui.move("zoom", "bottom-right");


        // store ui objects as variables
        const countySelect = document.getElementById("countySelect");
        const citySelect = document.getElementById("citySelect");
        const centerSelect = document.getElementById("centerSelect");
        const subtypeSelect = document.getElementById("subtypeSelect");
        const resetButton = document.getElementById("resetButton");
        const andButton = document.getElementById("andButton");
        const orButton = document.getElementById("orButton");
        
        // define default queries
        const defaultCountyQuery = "(COUNTY IS NULL OR COUNTY IS NOT NULL)";
        const defaultCityQuery = "(CITY IS NULL OR CITY IS NOT NULL)";
        const defaultCenterQuery = "(CENTER IS NULL OR CENTER IS NOT NULL)";

        const defaultSubtypeQuery = "(SUBTYPE IS NULL OR SUBTYPE IS NOT NULL)";

        const defaultLRquery = "(DIST_LR IS NULL OR DIST_LR IS NOT NULL)";
        const defaultFRquery = "(DIST_FR IS NULL OR DIST_FR IS NOT NULL)";
        const defaultBRTquery = "(DIST_BRT IS NULL OR DIST_BRT IS NOT NULL)";
        const defaultFWYEquery = "(DIST_FWYE IS NULL OR DIST_FWYE IS NOT NULL)";
        const defaultLogicOperator =  "AND";

        // set initial selection for geograhpy filters - could switch to a placeholder?
        let countySelectionCurrent = "None";
        let citySelectionCurrent = "None";
        let centerSelectionCurrent = "None";

        let countyQuery = defaultCountyQuery;
        let cityQuery = defaultCityQuery;
        let centerQuery = defaultCenterQuery;
        let subtypeQuery = defaultSubtypeQuery;

        let LRquery = defaultLRquery;
        let FRquery = defaultFRquery;
        let BRTquery = defaultBRTquery;
        let FWYEquery = defaultFWYEquery;
        let logicOperator =  defaultLogicOperator;
        

        let fullQuery = null;

        function generateFullQuery() {
          fullQuery = countyQuery + ' AND ' + cityQuery + ' AND ' + centerQuery + ' AND ' + subtypeQuery + ' AND (' + LRquery + ' ' + logicOperator + ' ' + FRquery + ' ' + logicOperator + ' ' + BRTquery + ' ' + logicOperator + ' ' + FWYEquery + ')' ;
        }

         // define initial definition expression
        const initialDefinitionExpression = generateFullQuery()

        // setup actions for the reset button
        resetButton.addEventListener("click", () => {
          [housingLayer].forEach((layer) => {
            
            countyActive = false
            cityActive = false
            centerActive = false
            

            // clear the definition expression
            layer.definitionExpression = null;
            
            fetchLocalJsonArray(jsonBase)
            .then(data => {
              
              const countyArray = data[0].COUNTY;
              const cityArray = data[0].CITY;
              const centerArray = data[0].CENTER;
              populateSelectBox('countySelect', countyArray);
              populateSelectBox('citySelect', cityArray);
              populateSelectBox('centerSelect', centerArray);

            });

            countyQuery = defaultCountyQuery; // work for now but should the select just be set to null instead?
            cityQuery = defaultCityQuery;
            centerQuery = defaultCenterQuery;
            subtypeQuery = defaultSubtypeQuery;
            subtypeQuery = defaultSubtypeQuery;
            LRquery = defaultLRquery;
            FRquery = defaultFRquery;
            BRTquery = defaultBRTquery;
            FWYEquery = defaultFWYEquery;
            logicOperator =  defaultLogicOperator;
            
            subtypeSelect.value = null;
            inputLR.value = null;
            inputFR.value = null;
            inputBRT.value = null;
            inputFWYE.value = null;
            logicOperator = "And"; 
            generateFullQuery()
            andButton.style.backgroundColor = "#0079c1";
            orButton.style.backgroundColor = "#797979";
            
          });
        });

        // setup actions for the AND button
        andButton.addEventListener("click", () => {
            logicOperator = "And"; 
            generateFullQuery()
            andButton.style.backgroundColor = "#0079c1";
            orButton.style.backgroundColor = "#797979";
        });

        // setup actions for the OR button
        orButton.addEventListener("click", () => {
            logicOperator = "Or";
            generateFullQuery()
            orButton.style.backgroundColor = "#0079c1";
            andButton.style.backgroundColor = "#797979";
        });


        let countyActive = false;
        let cityActive = false;
        let centerActive = false;

        // COUNTY - filter and zoom features, update select options
        countySelect.addEventListener("calciteSelectChange", () => {
          [housingLayer].forEach((layer) => { // fix this to include parcels and points in main app

            ;

            // selectionText = countySelect.options[countySelect.selectedIndex].text;
            selectionText = event.target.value;

            countySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              countyQuery = defaultCountyQuery
              countyActive = false
            }else{
              countyQuery = `COUNTY = '${selectionText}'`
              countyActive = true
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCounty)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;
              

              if ((cityActive !== true) && (centerActive !== true)){
                populateSelectBox('citySelect', cityArray);
                populateSelectBox('centerSelect', centerArray);   
              }           
              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)

            });
          });
          housingLayer.queryExtent().then((results) => {
            view.goTo(results.extent);
          });
        });

        // CITY - filter and zoom features, update select options
        citySelect.addEventListener("calciteSelectChange", () => {
          [housingLayer].forEach((layer) => { // fix this to include parcels and points in main app

            // selectionText = citySelect.options[citySelect.selectedIndex].text;
            selectionText = event.target.value;
            citySelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              cityQuery = defaultCityQuery;
              cityActive = false;
            }else{
              cityQuery = `CITY = '${selectionText}'`;
              cityActive = true;
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCity)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

             
              if ((countyActive !== true) && (centerActive !== true)){
                populateSelectBox('countySelect', countyArray);
                populateSelectBox('centerSelect', centerArray);              
              } if ((countyActive === true)){
                  populateSelectBox('countySelect', countyArray);
                  populateSelectBox('centerSelect', centerArray);
              } if ((centerActive === true)){
                  populateSelectBox('centerSelect', centerArray);
              }

              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)
            });
          });
          housingLayer.queryExtent().then((results) => {
            view.goTo(results.extent);
          });
        });

        // CENTER - filter and zoom features, update select options
        centerSelect.addEventListener("calciteSelectChange", () => {
          [housingLayer].forEach((layer) => { // fix this to include parcels and points in main app

            selectionText = event.target.value;
            centerSelectionCurrent = selectionText;
            console.log(selectionText)

            if(selectionText === "None"){
              centerQuery = defaultCenterQuery;
              centerActive = false;
            }else{
              centerQuery = `CENTER = '${selectionText}'`
              centerActive = true;
            }

            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
            
            // update the select options
            fetchLocalJsonArray(jsonCenter)
            .then(data => {
              const dataFiltered = data.find(item => item.NAME === selectionText);
              const countyArray = dataFiltered.COUNTY;
              const cityArray = dataFiltered.CITY;
              const centerArray = dataFiltered.CENTER;

              
              
              
              if ((countyActive !== true) && (cityActive !== true)){
                populateSelectBox('countySelect', countyArray);
                populateSelectBox('citySelect', cityArray);          
              } if ((countyActive === true)){
                  populateSelectBox('countySelect', countyArray);
                  populateSelectBox('citySelect', cityArray);
              } if ((cityActive === true)){
                  populateSelectBox('citySelect', cityArray);
              }

              setCalciteSelectValue(countySelect, countySelectionCurrent)
              setCalciteSelectValue(citySelect, citySelectionCurrent)
              setCalciteSelectValue(centerSelect, centerSelectionCurrent)

            });
          });
          housingLayer.queryExtent().then((results) => {
            view.goTo(results.extent);
          });
        });

        // SUBTYPE Select
        subtypeSelect.addEventListener("calciteComboboxChange", (event) => {
          [housingLayer].forEach((layer) => { // fix this to include parcels and points in main app


            selection = event.target.value;
            // console.log(selection);

            if (Array.isArray(selection) == false){
              if(selection === null | selection === " " | selection === ""){
                subtypeQuery = defaultSubtypeQuery
              }else{
                subtypeQuery = `SUBTYPE IN ('${selection}')`
              }
            }else{
              selection = selection.map(value => `'${value}'`);
              subtypeQuery = `SUBTYPE IN (${selection})`
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery)
            layer.definitionExpression = fullQuery;
          });
        });


        

        //initialize light rail dist filter
        const inputLR  = document.getElementById("inputLR");
        inputLR.value = null;
        inputLR.addEventListener("calciteInputChange", function(){

            userInput = inputLR.value;
            console.log(typeof(userInput))

            if (userInput === null | userInput === " " | userInput === ""){
              LRquery = defaultLRquery;
            }  else {
              LRquery = `DIST_LR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [housingLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });


        //initialize frontrunner dist filter
        const inputFR  = document.getElementById("inputFR");
        inputFR.value = null;
        inputFR.addEventListener("calciteInputChange", function(){

            userInput = inputFR.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              FRquery = defaultFRquery;
            }  else {
              FRquery = `DIST_FR <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [housingLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        //initialize BRT dist filter
        const inputBRT  = document.getElementById("inputBRT");
        inputBRT.value = null;
        inputBRT.addEventListener("calciteInputChange", function(){

            userInput = inputBRT.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              BRTquery = defaultBRTquery;
            }  else {
              BRTquery = `DIST_BRT <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [housingLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });

        //initialize FWYE dist filter
        const inputFWYE  = document.getElementById("inputFWYE");
        inputFWYE.value = null;
        inputFWYE.addEventListener("calciteInputChange", function(){

            userInput = inputFWYE.value;
            console.log(userInput)

            if (userInput === null | userInput === " " | userInput === ""){
              FWYEquery = defaultFWYEquery;
            } else {
              FWYEquery = `DIST_FWYE <= '${userInput}'`;
            }
            
            // update the main query
            generateFullQuery()
            console.log(fullQuery);

            [housingLayer].forEach((layer) => { 
              layer.definitionExpression = fullQuery;
            });
          });


        view.ui.add("sidebarDiv", { position: "top-left" });

      });

    </script>
  </head>

  <body>
    <div id="viewDiv"></div>

    <div id="sidebarDiv" class="grid-container">
      <div class="grid-item">
        <div class="child1">
          <b>County</b>
        </div>
        <div class="child2">
          <calcite-select id="countySelect"></calcite-select>
        </div>
      </div>
    
      <div class="grid-item">
        <div class="child1">
          <b>To TRAX (mi)</b>
        </div>
        <div class="child2">
          <calcite-input id="inputLR" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
        </div>
      </div>
    
      <div class="grid-item">
        <div class="child1">
          <b>City</b>
        </div>
        <div class="child2">
          <calcite-select id="citySelect"></calcite-select>
        </div>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>To FrontRunner (mi)</b>
          </div>
          <div class="child2">
            <calcite-input id="inputFR" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
          </div>
        </label>
      </div>
    
      <div class="grid-item">
        <div class="child1">
          <b>Center</b>
        </div>
        <div class="child2">
          <calcite-select id="centerSelect"></calcite-select>
        </div>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>To BRT (mi)</b>
          </div>
          <div class="child2">
            <calcite-input id="inputBRT" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
          </div>
        </label>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>Housing Type</b>
          </div>
          <div class="child2">
            <calcite-combobox id="subtypeSelect" placeholder="select housing types"></calcite-combobox>
          </div>
        </label>
      </div>
    
      <div class="grid-item">
        <label>
          <div class="child1">
            <b>To FWY Exit (mi)</b>
          </div>
          <div class="child2">
            <calcite-input id="inputFWYE" type="number" step=".5" min="0" clearable="true" placeholder="enter a distance"></calcite-input>
          </div>
        </label>
      </div>

      <div class="grid-item2">
       
          <div class="child3">
            <input id="resetButton" type="button" value="Clear Filters" class="esri-button" style="background-color: #0079c1;"/>
          </div>
       
      </div>

      <div class="grid-item2">
        <div  class="grid-container2">
          <div class="child4">
            <input id="andButton" type="button" value="And" class="esri-button" style="background-color: #0079c1;"/>
          </div>

          <div class="child4">
            <input id="orButton" type="button" value="Or" class="esri-button" style="background-color: #797979;"/>
          </div>
        </div>
      
      </div>



    </div>
  </body>